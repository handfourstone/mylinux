<span id="声明"></span>

# 声明

作者是基于内核4.10.0的版本来学习邻居子系统的。本篇绝大部分内容参考<< Understanding Linux Network Internals >>以及其译文<<深入理解linux网络技术内幕>>。后者是基于内核版本2.6.xx及其之前的版本编写的，相比于4.10.0的内核版本，该内核版本已经有许多东西被优化了。

本文中不会锁以及RCU的内容进行任何讨论。概念性的、原理性的东西主要参考<<深入理解linux网络技术内幕>>，因此不会有太大的变动，牵扯到源码的部分，就会有比较大的变动。

鉴于作者自身知识水平有限，本文中存在一些描述不准确的地方甚至会出现一些错误，请各位批评改正。

--2017.05.03 拓磊

<span id="邻居子系统"></span>

# 邻居子系统

<span id="何为邻居"></span>

## 何为邻居

属于同一个LAN的主机(也就是说，这两台主机通过一个共享介质相连或者点对点直接相连)之间互为邻居。定义邻居的另外一种方式是:一台主机到另一台主机必须有且仅有一个L3跃点，并且其L3路由表必须提供可以直接和另一台主机通信的一条路径。不是邻居的主机间的通信必须通过网关或路由器。如果两台主机被L2上的某个设备隔离，他们仍然是邻居。


<span id="需要邻居协议的原因"></span>

## 需要邻居协议的原因

<span id="L3地址需要转换成L2地址"></span>

### L3地址需要转换成L2地址

二层网络协议(Ethernet、802.11无线、点对点等)和三层网络协议(IP)的区别是:为了邻居间可以交换数据存在这许多不同的二层协议，而三层路由协议传输数据时不必关心使用哪种物理介质。在两个系统之间的高层协议应该能够使用同样的软件来发送封包，而不必关心他们是Ethernet链接还是点对点连接。

<span id="共享介质"></span>

### 共享介质

在共享介质中，任一主机发出的任何帧都会被直接连接到该介质上的所有主机收到，无线连接就是最简单的一个例子。

由于这个原因，在共享介质中使用的链路层协议需要定义之中寻址机制，以便发送方可以指定每个帧的接收方。通常这个寻址机制也定义一些特殊地址，通过这些地址可以发送一个帧到多个主机(多播地址)或所有主机(广播地址)。

<span id="为何没有足够的静态地址"></span>

### 为何没有足够的静态地址

L2与L3的地址通常情况下是一一对应的，但是出现下面情况的时候，这种对应关系会发生改变。

1. 动态配置\
	在IP网络中，通过协议的方式(例如，DHCP)可以给一台主机指定动态IP地址。同一台主机每次请求得到的地址可能会不同，但是硬件地址已经固化在NIC中，这个时候L3到L2的对应关系就要更新。

2. 故障接口的重新配置\
	一旦替换了主机的NIC，那么它的L2地址也就改变了，但是管理员可能更愿意在网络中保持同样的逻辑配置，因此L3地址是不变的，但是L2与L3的对应关系发生了改变。

3. L3地址的移动\
	某台服务器可能无法工作，这是就要求另外一台不同的服务器处理同样的流量。这意味着旧的L3地址应该被设置到新服务器的新接口上(参考[虚拟IP](#虚拟IP))。如果该主机换了一个网络接口，管理员想保持其L3地址不动，也会发生这种情况。

为了将上述变化从L2和L3隔离出来，因为它们有大量的工作要做，无法处理所有可能出现的情况并缓存相关数据，因此需要一个协议来管理L3地址到L2地址的关联。

<span id="特殊情况"></span>

### 特殊情况

有时候L3地址到L2地址的映射不需要任何协议就能完成，例如下面一些情况:

1. 仅有一台主机能够把数据发送到点到点介质上。
2. 有一些特殊的L3地址，他们与L2地址的关联通过一种简单的规则获得，因为这些地址不会产生歧义，没有动态的地址分配，也不需要任何协议。
3. 多播地址可以不需要任何协议实现静态转换。在IPv4/ARP网络中，arp_mc_map函数负责解析多播地址，若接口设备是Ethernet NIC，该函数会依次调用非常简单的函数ip_eth_mc_map。在函数ip_eth_mc_map中的映射不需要任何协议。只需要根据下面的步骤实现即可。
	1. 最高24位指定由IANA分配的静态地址01:00:5E。
	2. 第23位(低24位的最高位)设为0。
	3. 剩余的低23位直接复制自相应IP地址的低23位。
注意:相同的Ethernet多播地址可以设定多个IP地址(因为IP地址的最高9为没有使用)。
4. 广播地址(IP子网广播)静态解析为链路层广播地址(以太网是FF:FF:FF:FF:FF:FF)。

<span id="邻居请求与应答"></span>

### 邻居请求与应答

当不满足特殊情况下的L3到L2地址映射时，就需要邻居协议来完成这个映射。不同的邻居协议有不同的工作机制。但是所有的邻居协议都使用下面的两个术语。

- Solicitation请求(也叫做邻居solicitation)\
	本文中出现的邻居请求指的就是Solicitation请求。这个属于表示在网络中发出一个封包并轮询所有的主机，是否有主机知道这个L3地址对应的L2地址。根据不同的协议和实际情况，该请求可以以单播、多播、广播的形式发送出去。

- Solicitation应答(也叫做邻居advertisement)\
	本文中出现的邻居应答指的就是Solicitation应答。一般来说，这个属于指发出一个封包作为邻居请求的应答。但该封包也可以独立生成(参见[免费ARP](#免费ARP))。在正常条件下，与目的L3地址关联的主机会产生这个应答，但也可能是另一台主机替他产生应答(参见[邻居协议代理](#邻居协议代理))。该封包通常使用单播方式发送，特殊情况时也可以使用广播。

<span id="Linux实现"></span>

## Linux实现

下图给出了linux邻居子系统主要部分和内核中与其交互的其它部分。L3协议与邻居层的交互通过一个通用接口(参见[邻居协议与L3传输函数的交互](#邻居协议与L3传输函数的交互))，它根据请求定制映射的L3协议来使用正确的邻居协议。

							+------+        +------+        +-------------+
							| IPv4 |        | IPv6 | <----> | route table |
							+------+        +------+        +-------------+
								|               |
								V               V
							+----------------------+        +-------------+
							|        GNI(VFT)      | <----> | route cache |
		+-----------+		+----------------------+        +-------------+
		| ARP cache | <---> |    ARP    |    ND    | <----> |   ND cache  |
		+-----------+		+----------------------+        +-------------+
							|        GNI(VFT)      |
							+----------------------+
										| dev_queue_xmit
										V
							+----------------------+
							|        TC/QoS        |
							+----------------------+
										|
										V
							+----------------------+
							|     device driver    |
							+----------------------+
		GNI: Generic Neighbouring Interface。
		TC: Traffic Control。
		QoS: Quality of Service。
	
	Figure. the big picture

传输一个封包时，执行下面的步骤：

1. 本地主机的路由子系统选择L3目的地址(下一个跃点)。

2. 根据路由表，如果下一个跃点在同一个网路中(也就是说下一个跃点是邻居)，邻居层就把目的L3地址解析为L2地址。这个关联被放入缓存以便将来再次使用。这样的话，如果一个应用程序短期内发送多个封包给另一个应用程序，那么只在发送第一个封包的时候使用一次邻居协议。

3. 最后一个函数，比如dev_queue_xmit负责完成发送，将封包传递给流量控制或者QoS层。尽管上图中只给出了dev_queue_xmit，但邻居层实际也能调用其他函数。

dev_queue_xmit函数是在当要传输的封包准备发出去时才被调用的。因此，如果需要L2头部信息的话，邻居协议必须在调用该函数之前将L2头部增加到该封包上。点对点链接、广播、多播都不需要L2头部信息，因而也不需要L3到L2的映射。上述几种类型的传输在[特殊情况](#特殊情况)一节有介绍。其他的传输使用共享介质，因此就需要一个L2头部信息。该信息可能来自邻居子系统的缓存，或是来自邻居系统向网络发出的请求。

<span id="邻居协议"></span>

### 邻居协议

在现在的IP网络中使用两个邻居协议。绝大多数系统使用IPv4中的ARP协议。另一个更通用的协议(Neighbour discovery，ND)，它是为IPv6开发的。为了能在专有网络使用，Linux内核中支持其它邻居协议，比如DECnet使用的邻居协议，这里不做讨论。

尽管ARP被认为是一个L3协议，但其任务已经被IPv6的设计者们移到了L4。如下图所示，ND协议在IPv6中作为Internet消息控制协议(ICMP)的一部分。这样安排是根据多年来使用IPv4的经验。ND协议有许多优点，包括利用L3的一些特征，例如，IPsec加密。在[ND对ARP的改进](#ND对ARP的改进)一节会介绍ND和ARP的主要区别。

			  +--------+		+---------------+
			  |		   |		|		   +----|
			  | ICMPv4 |		| ICMPv6   | ND |
		+-----+--------+		+----------+----+
		| ARP |  IPv4  |		|     IPv6      |
		+-----+--------+		+---------------+
	
	Figure. Position of ARP/ND protocols in the network stack

**为了减少系统开销和所有邻居协议使用的相似服务间的代码重复，Linux提供了一个通用基础结构。通用邻居基础结构提供的服务可由不同协议根据其需要适当裁剪。下面是通用基础结构提供给这些协议的部分服务。**

1. 为每个协议存放一个缓存来存放L3到L2转换的结果。

2. 提供在缓存中增、删、改、查一个特定邻居项的函数。查找函数必须要快，因为它会影响整个系统的性能。

3. 为每个协议缓存的数据项提供一种老化机制。

4. 当缓存已满时并且正好要创建新的映射项时，提供选择替换策略。

5. 为每个邻居提供一个请求队列。当准备要发送一个封包且其L2地址还不在缓存中时，就必须把这个封包放到缓存区中，直到发出邻居请求并收到应答。

为了让每种协议都适应邻居子系统的行为，linux中定义可一组占位符或虚函数。这样每个协议都可以在其中插入它想要的函数。这与linux允许用户定制内核的方式有些相似，邻居层也提供了一组可调参数对其进行配置，配置这些参数可以通过用户空间命令、/proc文件系统或协议本身。最后，所有协议访问缓存的函数都是相同的，但不同的协议可能会用不同字节长度的关键字(L3地址)。因此，基础结构提供了一种通用方式来定义关键字使用的类型。后面的内容我们会详细介绍这些内容。

每个协议的运行和配置都是独立的，语气协议无关。在[协议初始化和清理](#协议初始化和清理)一节给出了一个邻居协议如何向内核注册和注销。

<span id="邻居协议代理"></span>

## 邻居协议代理

若一台主机将发往另一台主机的流量拦截下来，并且嗲体后者处理这些流量，那么这台主机就是一个代理。代理最常见的例子就是一台HTTP缓存服务器，它将发往受访问的web服务器的请求截断，然后把保存在自己缓存中的那些服务器上的网页提供给请求者，这种方式可以减少网络流量。

如果主机和应用程序不需要人为精确配置成从代理服务获益，这种代理称为透明代理。刚刚提到的一个HTTP缓存服务器就是一个透明代理的例子。如下图给出的两个HTTP代理的例子，同样的服务可以由透明代理提供也可以由非透明代理提供。

		(a)											(b)
					 /--------\										/--------\
					| Internet |								   | Internet |
					 \--------/										\--------/
					 	 ^												^
						 |												|
						 V												V
				+----------------+									+--------+
				| Router & proxy |									| Router |
				+----------------+									+--------+
						 ^												^
						 |												|
						 V												V
		=====================================		=================================
			^						^						^				^
			|						|						|				|
			V						V						V				V
		+--------+				+--------+				+--------+		+--------+
		| HOST A |				| HOST B |				| HOST A |		| HOST B |
		+--------+				+--------+				+--------+		+--------+
														proxy
	Figure. (a)Transparent proxy. (b)nontransparent proxy

1. (a)一个局域网可以通过安装在路由器上的代理来访问Internet。来自该局域网内的主机(比如HOST B)所有浏览器请求都通过路由器，因此管理员可以让路由器来截断并代理所有HTTP请求。这就是透明代理，因为局域网内的主机不需要进行任何配置或者使用任何特殊的浏览器。

2. (b)HOST B的浏览器被设置为使用代理服务器(proxy)来访问Internet，代理服务器只有在其自身缓存不命中时，才会使用路由器访问Internet。

当然，也有其它的选择。例如，代理有可能是一台单独的机器，而路由器被设置成将HTTP请求转发到该代理。代理是个很大的话题，这里不详细讨论了。

前面展示了一种普通的代理类型:HTTP代理或web代理，现在考虑本章中的邻居代理。邻居协议的代理服务器是一台主机，对不属于自己地址的solicitation请求，它能够代替用有这些地址的主机做出应答。因为有了代理，位于不同LAN中的主机可以相互通信，就好像在同一个LAN中。

例如，ARP代理通常用在IPv4网络中，实现从扁平型网络到子网型网络的地址转换，通信主机不需要特殊的协议，也不需要特殊的配置，因此代理对他们来说是透明的。但是如果代理服务器崩溃了，通过代理连接的主机之间的连通信也就消失了。如果使用多个代理服务器，就能够减轻上述影响。此时一台主机的solicitation请求可能会收到多个solicitation应答。只要选择最先到达的应答，就能够确定最快且伏在最小的代理服务器。

代理的使用也简化了被代理服务器接管的主机的配置。在[ARP代理服务器作为路由器](#ARP代理服务器作为路由器)一节会有范例。

在Linux内核支持的邻居协议中，只有IPv4和IPv6可以使用代理。通用邻居基础结构由这两个协议共同使用，每个协议都可以根据自己的需求来适应代理。

在[担任代理](#担任代理)一节，我们将看到协议无关的代理模块的详细设计(定时器，队列等)。在[ARP代理](#ARP代理)一节，我们将看到IPv4和ARP使用代理的特殊情况。

<span id="使用代理的条件"></span>

### 使用代理的条件

并不是所有的solicitation请求都会被代理服务器处理。代理服务器只有在满足下列条件时才会对solicitation请求做出应答:

1. 请求的地址和代理服务器收到请求的接口上配置的地址不属于同一个子网。因为代理服务器代理部分主机对solicitation请求做出应答，这些主机不能和发出solicitation请求的主机在同一个子网内。否则，目的主机自己就可以应答，不需要代理服务器应答。

2. 必须启动代理功能。有几个判断条件可以决定是否应当对某个请求使用代理，而且不同的邻居协议使用的判断条件不同。此外，linux内核提供两种代理形式:通用代理和特定代理。
	- 通用代理。基于设备的代理，代理所有的请求。IPv4中最常见，IPv6中不使用。\
	- 特定代理。基于目的地址的代理。代理特定的请求。IPv6的标准，IPv4中也可以使用。两种代理的优先级如下图所示。当一个主机收到一个对本地子网外某个地址的solicitation请求时，这台主机若是启动了代理功能就可以处理它。首先邻居子系统检查设备上的代理功能是否全局使能，如果没有，在检查该设备是否被配置为可以代理那个特定地址。
	
							yes +=============+ no
						--------| Local ADDR? |----------
						|       +=============+         |
						|                               |Device proxying
						|                               V
						|                       +==================+
						|               yes     | Is proxy enabled | no
						|       ----------------|    on RX NIC?    |-----
						|       |               +==================+    |
						|       |                                       |
						|       |                                       |Destination-based proxying
						|       |                                       V
						|       |                             +======================+
						|       |                       yes   | Is requested address | no
						|       |       ----------------------|  peoxyed on RX NIC?  |-------
						|       |       |                     +======================+      |
						|       |       |                                                   |
						V       V       V                                                   V
				+-------------------------------+                                   +----------------+
				| Reply to solicitation request |                                   | Ignore request |
				+-------------------------------+                                   +----------------+
				
			Figure. Priority between device and address peoxying

3. 在接收请求的代理服务器上以开启转发功能。因为代理服务器是插入到主机之间的，所以它必须接收两个端点之间的转发流量。

ARP solicitation请求总是发往L2广播地址。这就保证了所有共享介质上的主机都可以收到它。这样代理服务器就不需要把其任何接口配置成混杂模式，就可以截取地址是他代理的主机的请求。当进行可到达性确认时(参见[可到达性确认](#可到达性确认))，ARP使用单播而不是广播。

ND协议使用L3多播地址处理solicitation请求和应答。当路由器想代理一个特定的IP地址时，它必须能够接收对应的L3多播地址。

<span id="何时发送和处理solicitation请求"></span>

## 何时发送和处理solicitation请求

接下来将会介绍，根据接收请求的主机的配置情况和网络的物理拓扑结构，什么时候应该处理solicitation请求。下图给出了导致主机发出solicitation请求的一些因素，下下图给出了接收到该请求的linux主机用于决定对其处理的常见因素。为了能够说明接收者决定过程的潜在复杂性，下下图假设主机同时具备代理和桥接功能。去掉任何一个都会简化处理流程的复杂度。下下图也假定代理类型是全局代理，特定代理的处理流程与此类似。下下图给出了代理服务器的情况和没有实施任何代理的普通主机的情况:“代理开启”指一台代理服务器，而“代理关闭”指一台普通主机。

					-----------------------------------------
					|										|
					V										V
		 +---------------------+				+--------------------------+
		 | Same logical subnet |			----| Different logical subnet |-----
		 +---------------------+			|	+--------------------------+	|
					|						|									|
					|						V									V
					|				+-----------------+				+---------------------+
					|				| Route available |				| No route available  |
					|				| (or default GW) |				| (and no default GW) |
					|				+-----------------+				+---------------------+
					|						|									|
					V						V									V
		+----------------------+	+-----------------+				+-----------------------+
		|   Solicitation for   |    | Solicitation for|				| Error,no solicitation |
		| destination address  |	|  for GW address |				|      is generated     |
		+----------------------+	+-----------------+				+-----------------------+
	
	Figure. Transmitting solicitation requests

																-------------------------------------------------
																|												|
																V												V
														+----------------+								+---------------+
														| bridge disable |								| bridge enable |
														+----------------+								+---------------+
																|												|
																V												|
										-----------------------------------------								|
										|										|								|
										V										V								|
								+-----------------+						+----------------+						|
								|    Different    |						|      same      |						|
								| logical subnet  |						| logical subnet |						|
								+-----------------+						+----------------+						|
										|										|								|
										V										V								|
							-------------------------					---------------------					|
							|						|					|					|					|
							V						V					V					V					|
					+---------------+		+----------------+	+----------------+	+---------------+			|
					| Proxy enabled |		| Proxy disabled |	| remote address |	| local address |			|
					+---------------+		+----------------+	+----------------+	+---------------+			|
							|						|					|					|					|
							V						|					|					|					|
				-----------------					|					|					|					|
				|				|					|					|					|					|
				V				V					|					|					|					|
			+---------+		+---------+				|					|					|					|
			| Invalid |		|  Valid  |				|					|					|					|
			| address |		| address |				|					|					|					|
			+---------+     +---------+				|					|					|					|
				|				|					|					|					|					|
				V				V					V					V					V					V
		+------------+	+--------------+	+--------------+	+--------------+	+--------------+	+--------------+
		| Proxy will |	| Solicitation |	| Solicitation |	| solicitation |	| solicitation |	| solicitation |
		| not reply  |	|   will be    |	|  is droped   |	|  is ignored  |	| is processed |	|  is bridged  |
		+------------+	| processed by |	+--------------+	| (Target host |	+--------------+	+--------------+
						|  the proxy   |						|  will reply  |
						+--------------+						|    to the    |
																| solicitation)|
																+--------------+
		
	Figure. Processing ingress solicitation requests

当接收到soolicitation请求的主机启动桥接功能时，该主机对其不进行处理，而是按照网桥配置，将其从合适的借口上转发出去。桥接功能在邻居协议之前起作用，因此，在linux处理solicitation请求的过程中，桥接模块先于代理模块处理请求。

现在假定关闭桥接功能。在一个共享介质中的一台主机能够接收到目的地址是其他主机的solicitation请求，下面是能够影响linux决定是否应答入口solicitation请求的一些因素。

1. 逻辑子网(logical subnet):IP子网。

	当请求解析的地址和配置在接收该solicitation请求的NIC上的L3地址属于同一个逻辑子网时，就出现上图的"same logical subnet"情况。

	当两台主机属于同一逻辑子网时，他们可以直接通信。否则，需要有路由器的帮助才能完成。

	注意，一个接口上可能配置了属于同一个逻辑子网的多个地址(其中一个是主地址，其它的是辅地址)，或多个地址属于不同的子网，再或者两种情况皆而有之。如果接收请求的NIC上配置了多个不同子网的地址，那么请求解析的地址必须属于其中的一个子网。

2. 物理子网(physical subnet):LAN。

	当两台主机属于同一个LAN时，它们理论上可以直接通信，但它们实际上能否可以还要根据LAN中的逻辑(L3)配置。

	一台主机不会试图去解析属于不同的的逻辑子网的另一台主机的地址。相反，他会解析路由器的地址，因为路由器是该主机要访问远程主机所必须的。

	一台主机永远不会在其NIC上收到这个一个solicitation请求:请求的地址是另一块NIC上的L3地址，除非使用代理。

		+----------------+		+----------------+
		|      PC1       |		|      PC2       |
		| 192.168.2.1/24 |		| 192.168.3.1/24 |
		+----------------+		+----------------+
				|						|
				|						|
		=========================================== LAN
		PC1与PC2属于同一个LAN，但逻辑子网不同，所以不能通信。想要通信，就必须要有路由转换。
	图1-6

3. 代理服务器的要求

	代理服务器并不是处理所有的solicitation请求，参见[使用代理的条件](#使用代理的条件)一节，在[处理入口ARP封包](#处理入口ARP封包)

<span id="邻居状态和网络不可到达性探测"></span>

## 邻居状态和网络不可到达性探测(NUD)

下图给出了传送一个封包到某个L3地址时，内核工作的简化过程。

		+=======================+ no
		| Is resolution needed? |----------------------------------------------------
		+=======================+													|
					|yes															|
					V																|
		+=============================+ yes		+-----------------------+			|
		| Is result already in cache? |-------->| Get it from the cache |--------	|
		+=============================+			+-----------------------+		|	|
					|no															|	|
					V															|	|
			+============+ success  +-----------------------+					|	|
			| resilve it |--------->| Store it in the cache |----------------	|	|
			+============+			+-----------------------+				|	|	|
					|failure												|	|	|
					V														V	V	V
			+-----------------+											+---------------+
			| Return an error |											|      End      |
			+-----------------+											+---------------+
		
	Figure. L3-to-L2 address resolution steps.

上图这个简化模型代表了大多数情况。但是，linux内核使用更为复杂的模型来处理所有可能的状态。

<span id="可到达性"></span>

### 可到达性

下图是一个简化的状态转换图。

											+--------------+
				Max num solicitation		| Just created |
				not reached        			+--------------+
				--------->-------->------\			|start resolution
				^						  \			|
				|		 Not reply		   \		|
				|		 within a given		\		V			Received
		+--------------+ amount of time  +-------------------+  solicitation reply +----------------------+
		| Solicitation |<----------------| Send solicitation |--------->---------->| Resolution completed |
		|    failed    |				 +-------------------+                     |     successfully     |
		+--------------+							|                              +----------------------+
				|									|
				|	Max num solicitation			V
				V	reached		 		 +-------------------+
				----->------------->---->| Resolution failed |
										 +-------------------+
		
		Figure. Status of an L3-to-L2 mapping

从邻居的角度来说，如果内核有证据表明接收者可以正确的接受地址是其单播地址的帧，那么这台主机就认为是可到达主机，反之亦然。换句话说，内核认为一个邻居可到达时，表示是双向可到达的，后续的内容中，我们所说的可到达就意味着双向可到达。在[可到达性确认](#可到达性确认)一节中，我们会看到有两种方式来证实可到达性:L4确认和solicitation应答。

<span id="NUD状态之间的转换"><span>

### NUD状态之间的转换

IPv6定义了一种NUD机制，它能快速判断邻居是否断线或死机。Linux内核对IPv4和IPv6使用同样的机制。我们没有详细介绍的DECnet也使用类似的机制。

下图总结出了邻居可能处于的状态和触发状态转换的条件。每个邻居项可以由多个事件创造，包括传输数据封包到邻居的请求，或者收到来自邻居的solicitation请求。

一个邻居项的状态在其生存期内可能会改变多次，并且同一个状态可以多次被同一个邻居项使用。不同的协议也许为了利用特殊条件，也许执行不同的状态转换，包括图中一些没有给出的状态转换。例如IPv4可以直接把一个新邻居项的状态设置为NUD_STALE态，但IPv6不行。

下面介绍下图中所示的状态。根据不同状态之间的一些共性将状态按组分类。下面按照下图中的状态转移进行介绍，尤其是对NUD机制。

													+-----------+
							-------<--------<-------| New entry |----->------>---
							|						+-----------+				|				1. multcast/broadcast
							|							|	|					|Special cases	2. loopback device
							|				------<------	|					|				3. point to point device
							V				|				|					V				4. device that does not
					 ###############		|		   ##########		  ###########			   need to resolve the
					 #NUD_PERMANENT#		|		   #NUD_NONE#		  #NUD_NOARP#			   mapping
					 ###############		|		   ##########		  ###########
											|				|
						------------<-------				|
						|									|solocit request send
						|					  ---->--		|
		 Address learned|					  |		|		V TIMER
		 from an ingress|	     Timer expired|	  ################		Timer expired(no more attemps available)
		 socilit request|	     (more attemps|	  #NUD_INCOMPLETE#-->----------------------------------------------------
						|	     available)	  |	  ################														|
						|					  |		|		|															|
						|					  --<----		|Received proof of reachability								|
						|									|(solicit apply)											|
						|									V															|
						|							 ###############				Receive proof of reachability		V
						|	------------------<------#NUD_REACHABLE#---<-------------------------(solicit reply			|
						|	|						 ###############							|or L4 confirm)			|
						|	|								|									|						|
		================|===|===============================|===================================|======================	|
		|				|	| Entry not used for more		^									|					  |	|
		|				|	| than REACHABLE_TIME secconds	| Received proof of reachability	|					  |	|
		|	 ----->--	|	|								^ (silicit reply or L4 confirm)		^	   --<---		  |	|
		|	 |		|	V	V								|									|	   |	|		  |	|
		|	 |	   ###########						   ###########							  ###########	|		  |	|
		|	 |	   #NUD_STALE#----------------->-------#NUD_DELAY#------>---------------------#NUD_PROBE#	|		  |	|
		|	 |	   ###########		Entry used		   ########### Timer expired			  ###########	|		  |	|
		|	 |		|	|								TIMER	   (delay_probe_time)			| TIMER|	|		  |	|
		|	 --<-----	|																		|	   ---->-		  |	|
		|	Entry not	|																		|		Timer expired |	|
		|	used for	|																		|		(more attemps |	|
		|	less than	|																		|		available)	  |	|
		|	gc_staletime|																		|					  |	|
		|	secconds	V																		|Timer expired		  |	|
		|				|																		|(no more attemps	  |	|
		|				|				Reachability confirmation								|available)			  |	|
		================|=======================================================================|====================== |
						|																		V						|
						|																  ############					|
						|																  #NUD_FAILED#----------<--------
						|																  ############
						|																		|
						|																		|Garbage collection
						|Entry not used for more than gc_staletime seccond						V
						|(and reference count=1)										+----------------+
						------->------------------------------------------------->------| Entey deletion |
																						+----------------+
	Figure. Transitions among NUD states.

<span id="基本状态"></span>

#### 基本状态

我们根据上图，从新建一个邻居项时的默认状态开始介绍。

1. NUD_NONE

	邻居项刚被创建，还没有状态可用。

2.  NUD_INCOMPLETE

	一个**邻居请求**已经发出，但还没有收到应答。在这个状态，不是用任何硬件地址(甚至旧地址也不使用，那是NUD_STALE状态)。

3.  NUD_REACHABLE

	邻居的地址被放入缓存，并且知道该邻居是可到达的(已经有了可到达性证据)。

4. NUD_FAILED

	由于邻居请求失败，将邻居标记为不可到达。当创建一个新邻居项时有可能进入该状态，或者NUD_PROBE状态也会触发到该状态。

5. NUD_STALE

	缓存中包含该邻居的地址，但是该地址已经有一段时间(struct neigh_parms -> reachable_time )没有进行确认了，到下次有封包要到达这个邻居时，要启动可到达性认证进程。

6. NUD_DELAY

	当发送一个封包到一个邻居，且该邻居相关的缓存项处于NUD_STALE时，就进入这个状态。NUD_DELAY状态表示一个时间窗，通过窗口可以通过外部主机来证实该邻居的可到达性。最简单的确认方式就是，若被怀疑的邻居发出一个封包，则表明它仍在运行且能够访问。

	为了进行可达性确认，该状态给网络层一个时间期限，这个期间内内核不发出邻居请求，这样节省了网络带宽，这样节省了网络带宽、降低了CPU的利用率。

	如果请求没有被确认，那么该缓存项就进入下一个状态:NUD_PROBE。这个状态通过明确的邻居请求，或者协议使用的其它机制判定指定邻居的状态。

7.  NUD_PROBE

	邻居状态处于NUD_DELAY是，在时间窗口结束之前，还没有收到该邻居的可到达性验证时，它的状态就转变为NUD_PROBE，同时开始发送**邻居请求**消息。

8. NUD_NOARP

	该状态用于标记不要任何协议进行L3到L2的地址映射的邻居。

9. NUD_PERMANENT

	邻居的L2地址是静态配置(也就是说使用用户空间命令)。

<span id="派生状态"></span>

#### 派生状态

除了上一节列出的基本状态外，还定义了下面的一些派生状态，在涉及多个有共同的状态时，这些派生状态可以使代码更清晰。

1. NUD_VALID

	如果某邻居项的状态是下列状态之一，那么它被认为是NUD_VALID态。这些状态代表邻居项有一个可用的二层地址。

	NUD_PERMANENT\
	NUD_NOARP\
	NUD_REACHABLE\
	NUD_PROBE\
	NUD_STALE\
	NUD_DELAY

2. NUD_CONNECTED

	这个状态是NUD_VALID的子状态，没有未决的确认要处理就是该状态。

	NUD_PERMANENT\
	NUD_NOARP\
	NUD_REACHABLE

3. NUD_IN_TIMER

	当一个邻居项的状态不是很清晰时，邻居子系统就为其运行一个定时器。与此相关的基本状态是包括:

	NUD_INCOMPLETE\
	NUD_DELAY\
	NUD_PROBE

下面用一个例子来说明内核代码中派生状态的作用。当删除一个邻居项之前，需要停止所有与它相关联还在运行中的定时器。执行这个人物以前需要将邻居状态分别和与他关联的三个有未决的计时器的状态比较，定义NUD_IN_TIMER态后，这个过程就很简单，只要对邻居的状态与NUD_IN_TIMER进行比较就可以，这个比较是通过按位与来实现的。

#### 初态

当创建一个邻居实例时，其默认状态为NUD_NONE。若是通过明确的用户命令创建的，那么其初态就可以明确设置为其它任何态。

在[邻居初始化](#邻居初始化)一节中会提到，邻居协议的constructor方法可以根据相关设备(例如，点对点连接)的特性和L3地址(例如，广播地址)改变邻居状态。

### 可到达性确认

我们在[为何没有足够的静态地址](#为何没有足够的静态地址)一节提到过，L3地址到L2地址的映射是可以改变的。基于此原因，有必要对保存在缓存中的信息定期确认，看看是否有信息在一段时间内没有使用，这个过程叫做可到达性确认。

注意，可到达性状态的改变不只是由于[需要邻居协议的原因](#需要邻居协议的原因)一节所列出的原因，路由器、网桥或者其它网络设备除了故障，也会导致这个问题，当正在进行可到达性确认时，linux假定缓存中的信息仍然是可以使用的。


NUD_STALE、NUD_DELAY、NUD_PROBE三个状态都支持可到达性确认。使用这些状态的主要原因是，只有一个封包要发送到相关的邻居时，才启动可到达性确认。

邻居的可到达性状态可以通过两种方式进行确认。这两种方式各自的权限等价不同:

1. 来自单播的solicitation应答认证

	当你的主机收到一个solicitation应答时，该应答是作为他以前发出的solicitation请求的回应，这就意味着邻居收到那个请求并且做出了回答，也就是说邻居已经有了你的L2地址，或者说从你的请求中得到了你的地址(参见[创建一个邻居项](#创建一个邻居项)一节)。同时还表示存在一个双向的有效路径。但是上述一切只有在solicitation应答作为单播发出时才是成立的。广播应答的接收将缓存项的状态转移到NUD_STALE态而不是NUD_REACHABLE态(在[处理入口ARP封包]一节，将会从ARP的角度对这个问题进行详细解释)。

2. 外部认证

	如果你的主机确定自己收到一个来自邻居的封包，该封包是对以前发送的某个封包的应答，那么就可以假定邻居依然是可到达的。下图给出了这样一个例子，当途中主机A收到来自主机B的SYN/ACK封包时，该封包是对主机A的SYN封包的应答，就证实主机B是可以到达的。注意，如果主机B不是A的邻居项，来自B的SYN/ACK应答将证明主机A到达主机B时使用的下一跳网关是可到达的。

					+-------------------+	(1) SYN			+-------+
					|         TCP       |------------------>|		|
					|                   |<------------------|  TCP  |
				(3a)| ------dst_confirm |	(2)	SYN/ACK		|		|
					+-|-----------------+					+-------+
					| V         IP      |					|		|
					|                   |					|  IP	|
				(3b)| ----neigh_confirm |					|		|
					+-|-----------------+					+-------+
					| V     NEIGH       |					| NEIGH	|
					|                   |					|		|
					+-------------------+					+-------+
					
					HOST A								HOST B
					IP:10.0.1.1/24						IP:10.0.1.2/24
					MAC:00:20:ED:76:1E:12				MAC:00:20:ED:76:1E:13
					+-------+							+-------+
				----|		|							|		|
				|	+-------+							+-------+
				|		|eth0								|eth0
				|	============================================= subnet 10.0.1.0/24
				V
			+----------------------------------------------------------------------+
			|																	   |
			|	(1)	+------+----------+-------------------+---------------+		   |
			|	----| eth0 | 10.0.1.2 | 00:20:ED:76:1E:13 | NUD_STALE     |		   |
			|	|	+------+----------+-------------------+---------------+	(3)    |
			|	--->| eth0 | 10.0.1.2 | 00:20:ED:76:1E:13 | NUD_DELAY     |----    |
			|		+------+----------+-------------------+---------------+   |    |
			|		| eth0 | 10.0.1.2 | 00:20:ED:76:1E:13 | NUD_REACHABLE |<---    |
			|		+------+----------+-------------------+---------------+        |
			|																       |
			+----------------------------------------------------------------------+
			
		Figure. Example of external neighbor reachability confirmation

	确认是通过dst_confirm函数完成的，该函数证实了用于向主机B路由SYN封包的路由表缓存项的有效性。dst_confirm是对neigh_confirm函数的简单封装。后者完成我们前面描述过得任务:确认邻居的可到达性并且完成L3到L2的映射。注意:neigh_confirm只更新neigh->confirmed时间戳，neigh_periodic_work函数(当邻居项进入NUD_DELAY态时，启动的定时器到期后执行该函数)负责将邻居项状态更新为NUD_REACHABLE态。

	注意，由于IP层不对封包中数据流做任何处理，所以它无法检测在上图中的两个封包的相关性。这也是用L4来处理封包的原因。TCP SYN/ACK封包是L4协议提供额外认证的一个例子。给定一个套接字，以及相关的路由缓存项和下一跳网关地址，用户空间程序在类似send和sendmsg的传输函数中使用MSG_CONFIRM选项，就可以确认该网管的可到达性。

	solicitation应答的接收使状态转换到NUD_REACHABLE态，而不管当前状态如何。只有当前状态是NUD_STALE态时，才能使用外部认证。如果缓存项刚刚创建，那么它处在NUD_INCOMPLETE态，此时不允许通过外部认证来确认邻居的可到达性。参见上上图。

注意:NUD_DELAY/NUD_PROBE和NUD_NONE态都可以转换到NUD_REACHABLE态，如上上图所示。但是，从NUD_NONE态到NUD_REACHABLE态，需要完整的可到达性验证。而从NUD_DELAY/NUD_PROBE态转换过去，满足任何验证都可以。

# 邻居子系统:基础结构

前面我们看到了邻居协议要解决的主要问题，也知道linux内核将部分解决方法抽象为一个通用基础结构，并且这个通用基础结构由各种邻居协议共同享用。本章我们将看到这个基础结构是如何设计的。尤其是邻居协议如何与这个通用基础结构相连，代理和缓存是如何实现的，以及外部子系统(例如，高层协议)如何将其关心的事件通知邻居协议。接下来还会说明L3协议，例如IPv4，如何与它们的邻居协议相连接，以及等待地址解析的缓冲区队列是如何实现的。

## 主要的数据结构

为了理解邻居基础结构的代码，我们首先对邻居子系统中使用较多的一些数据结构做一下介绍，并且解释他们之间是如何交互的。

这些数据结构的定义绝大部分在include/net/neighbour.h文件中。

1. struct neighbour

	存储邻居的有关信息，例如，L2和L3地址、NUD状态，访问该邻居经过的设备等。注意，一个neighbour项不是与一台主机相关联，而是与一个L3地址相关联。因为一台主机可能会有多个NIC，也就有多个L3地址。

2. struct neigh_table

	描述一种邻居协议的所有参数和函数。每个邻居协议都有一个该结构体的实例。所有的实例都插入到由一个静态变量neigh_table指向的全局表中。

3. struct neigh_parms

	对每个设备上邻居协议进行调整的一组参数。由于在大部分接口上可以启动多个协议(例如IPv4和IPv6)，所以一个net_device结构可以关联多个neigh_parms结构。

4. struct neigh_ops

	一组函数，用来表示L3协议(如IP)和dev_queue_xmit之间的接口。在下面一节[L3协议和邻居协议间的通用接口](#L3协议和邻居协议间的通用接口)中还有对其详细介绍。这些虚拟函数可以根据它们使用的上下文环境来改变(也就是说根据前面介绍的邻居的状态)。

5. struct hh_cache

	缓存链路层头部信息用于加快传输速度。一次将一个头部信息复制到发送缓冲区中比一个一个字节填充它快很多。并不是所有的网络设备都支持缓存头部信息。参考[L2帧头缓存](#L2帧头缓存)一节。


6. struct rtable
7. struct dst_entry

	//////////////////////////////////////////////////////////////////////
	当主机需要路由一个封包的时候，首先会查询自己的路由缓存中的目的主机信息，在缓存不命中时，接着才会查询路由表。每次查询路由表时，都会将结果保存在路由缓存中。IPv4路由缓存由结构rtable组成，每一个rtable实例对应于一个不同的IP地址、下一跳地址和一个dst_entry类型结构，用于存储与协议无关的信息。dst_entry包含一个指向neighbour结构的指针，该neighbour结构和下一跳地址有关。

邻居协议也使用一些小的数据结构。例如，pneigh_entry结构用于基于目的地址的代理，neigh_statistics结构用于收集邻居协议的统计数据。第一个结构在[担任代理](#担任代理)一节会介绍。图中也包含下面一些数据结构:

8. in_device、inet6_dev

	分别保存某个设备上的IPv4和IPv6配置信息。

9. net_device

	对内核识别的每个网络设备都有一个net_device结构。












L3协议和邻居协议间的通用接口

linux内核有个通用邻居层，通过一个虚拟函数表(Virtual Function Table, VFT)将L3协议和主要的L2传输函数链接起来。VFT是Linux内核最常用的机制，可以使各个子系统在不同的时间使用不同的函数。邻居子系统的VFT是由neigh_ops结构实现的。在每个neighbour结构的ops字段中有有一个指针，指向neigh_ops结构。

【编者注】VFT，类比一下C++中的虚函数。这种函数的内容为空，每个成员可以按照自己的需求量身实现自己的函数功能，然后，对外表现出来的接口是一致的。

接下来介绍邻居子系统的VFT第一次初始化及在一个邻居的生存期内VFT如何更新。

先来看neighbour结构，这里我们之关系两个字段。

	struct neighbour {
		```
		const struct neigh_ops *ops;
		```
		int (*output)(struct neighbour *, struct sk_buff *);
		```
	};

再来看neigh_ops结构。

	struct neigh_ops {
		int family;
		void (*solicit)(struct neighbour *, struct sk_buff *);
		void (*error_report)(struct neighbour *, struct sk_buff *);
		int (*output)(struct neighbour *, struct sk_buff *);
		int (*connected_output)(struct neighbour *, struct sk_buff *);
	};

- solicit: 发送邻居请求的函数
- error_report:一个邻居被认为不可达时就调用这个函数
- output:用于所有情况
- connected_output:当邻居是可到达的，就会使用该函数。

当给定了一个neighbour项，并且对字段ops进行了初始化。那么，想要调用neigh_ops中的output字段所指向的函数，需要进行如下调用方式。

	struct neighbour *neigh;
	neigh->ops->output;

这中做法，并没有在linux中得到应用，因为不够通用。neigh_ops结构中的四个函数功能类似，无论那个协议，最后都要调用这四个函数中的一个。具体用哪一个，这与当前的环境、设备配置情况有关。因此，为了剥离这些环境与配置的差异，在neighbour中定义了自己的output字段，每个协议在适当的时候从neigh_ops中选择一个函数出来赋值给neighbour中的output。这样，在邻居基础结构中，代码就比较清晰了。无论那种情况，都只需要使用如下调用来替换想面的调用。

	neigh->output;

neighbour->ops的初始化


neighbour->output和neighbour_state的初始化

邻居的output与其状态紧密相连(后者决定前者的取值)。邻居子系统提供一个通用函数neigh_update，它能够将邻居的状态改变为其输入参数中提供的状态。下面是一个简略的邻居状态转换图，并且给出了转换过程中要调用到的函数。

									###############
				------------<-------#NUD_REACHABLR#---<------------------
				|	neigh_suspect	###############		neigh_connect	|
				|						|	|							|(II)
			 (I)|					 (I)|	^(I)						^
				V						V	|							|
		###########		(III)		###############		(I)			###########
		#NUD_STALE#----->-----------#  NUD_DELAY  #----->-----------#NUD_PROBE#
		###########					###############					###########
	部分状态改变是异步的:这些转变由一个定时器管理，通过比较时间戳(time_after_eq/time_before_eq)进行触发。其他的状态转移由协议负责同步(例如neigh_event_send)。

普通状态改变函数:neigh_connect和neigh_suspect

邻居进入NUD_REACHABLE态的主要方式是:

<span id="收到"></span>

- 收到一个邻居应答\
	收到一个邻居应答时，可能是由于第一次解析某个地址，也可能是由于确认邻居是否处于NUD_PROBE状态，协议就会通过neigh_update更新neigh->nud_state。这个更新立即发生，并且是同步的。
- L4认证\
	当收到一个L4可到达性确认后，就会第一次执行neigh_timer_handler函数，当收到一个L4可到达性确认后，就会第一次执行neigh_timer_handler函数，邻居状态就会改变为NUD_REACHABLE态。L4的确认是异步的并且可能会有稍微的延迟。
- 人工配置\
	当用户使用系统管理命令创建一个新的neighbour结构时，在该命令中可以指定命令状态，且NUD_REACHABLE态是合法的。这种情况下，通过neigh_update来调用neigh_connect。

无论什么时候进入NUD_REACHABLE太，邻居基础结构就调用neigh_connect函数，将neighbour->output指向neigh_ops->connected_output。

当某个邻居由NUD_REACHABLE态转移到NUD_STALE态或者NUD_DELAY态，或者仅仅初始化为与NUD_CONNECTED中的任一状态不同的状态(通过调用neigh_update可以实现)时，内核就请求neigh_suspect执行可到达性确认。这个工作由neigh_suspect完成，它将neighbour->output赋值为neigh_ops->output。

neighbour->output使用的函数

neighbour->output由邻居的constructor函数初始化，之后由函数neigh_connect和neigh_suspect根据协议事件的结果对其操作。neigh->output总是被设置成neigh_ops的一个虚拟函数。下面列出的函数可以被指定为neigh_ops的虚拟函数。

- dev_queue_xmit\
	当要传输一个封包时，L3总是调用这个函数，而不管接口设备的种类或者使用什么样的L3和L2协议。当出口设备上传输需要的所有信息都准备好，并且邻居子系统没有其它工作时，邻居协议就会将neigh_ops的函数指针初始化为dev_queue_xmit。
- neigh_connect_output\
	该函数只是填充L2帧头，然后调用dev_queue_xmit函数发送封包。因此，它希望L2地址被解析。邻居项在NUD_CONNECTED状态会用到这个函数。
- neigh_resolve_output\
	该函数在数据传输前将L3地址解析为L2地址。因此，当L3地址和L2地址的对应关系还没有建立或者需要对其进行确认时，就会用到该函数。如果创建一个邻居新结构并且需要对其L3地址进行解析时，neigh_resolve_output就会作为其默认函数。
- neigh_blackhole\
	该函数用于处理邻居结构不能被删除的临时情况，因为有人仍然要调用这个邻居项。函数neigh_balckhole会丢弃在输入接口上接收的任何封包。为了确保任何试图给该邻居传送封包的行为不会发生，这样的处理是必须的。因为该邻居项即将被删除。

#邻居信息更新:neigh_update
neigh_update定义在文件net/core/neighbour.c中，是用于更新邻居项链路层地址的通用函数。

	int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, u32 flags)

1. neigh:指向要更新的邻居项。
2. lladdr:新的链路曾地址。lladdr并不总是初始化为一个新值。例如，当调用neigh_update来删除一个邻居项时，会给lladdr传递一个NULL值。
3. new:新的NUD状态。
4. flags:用于传达信息，例如，是否覆盖一个已有的链路层地址等。下面是一些来自include/net/neighbour.h文件中的一些有效flags。
	- NEIGH_UPDATE_F_AMDIN\
		管理性改变。意思是说改变来自用户空间命令。
	- NEIGH_UPDATE_F_OVERRIDE\
		指当前的地址可以被lladdr覆盖。
	- NEIGH_UPDATE_ISROUTER (只用在IPv6)\
		表示这个邻居是个路由器。这个标识用于初始化neighbour->flag中的IPv6标识NTF_ROUTER。
	- NEIGH_UPDATE_F_OVERRIDE_ISROUTER (只用在IPv6)\
		表示IPv6 NTF_ROUTER标识可以被覆盖。
	- NEIGH_UPDATE_F_WEAK_OVERRIDE (只用在IPv6)\
		如果输入参数中提供的链路层地址lladdr与当前已知邻居neigh->ha的链路层地址不同，那么这个地址就是可以的(也就是说，邻居的状态会转移到NUD_STALE，以便触发可到达性认证)。

下面对该函数详细剖析

													+----------------+
													| Lock neighbour |
													+----------------+
															|
															V
													+==================+
													| Is current state | yes +===================================+ no
													|  NUD_NOARP or    |---->| Is this an administrative change? |---->[1]
													| NUD_PERMANENT?   |	 +===================================+
													+==================+						|yes
															|no									|
															|<-----------------------------------
															V
											+==============================+ yes
											| can this neigh be destroyed? |----->[1]
											+==============================+
															|no
															V
										yes	+==============================+ no
									--------| Is this new state NUD_VALID? |---------
									|		+==============================+		|
									|												|
									V												V
								+======================+					+------------+
							 no |  Did this neighbour  |					| stop timer |
						--------| already have lladdr? |					+------------+
						|		+======================+							|
						|				|yes										V
						V				|							+=============================+ yes
		+-----------------------------+	|							| Is old state NUD_CONNECTED? |------
		| Set lladdr equal old lladdr |	|							+=============================+     |
		+-----------------------------+	|											|					V
				|						V											|			+-----------------+
				|			+======================+ no								|			| neigh_suspect() |
				|			| new lladdr not NULL? |---------						|			+-----------------+
				|			+======================+		|						|					|
				|						|yes				|						|<-------------------
				|						V					|						V
				|		+==============================+	|			+-------------------------+
				|	 no |  old state equal NUD_VALID   |	|			| Update neigh->nud_state |
				|<------|			  &&			   |	|			+-------------------------+
				|		| old lladdr equal new lladdr? |	|						|
				|		+==============================+	|						V
				|						|yes				|				+=========================+ yes +-----------------+
				|						V					|				| Is old state NUD_VALID? |---->| set notify flag |
				|		+-----------------------------+		|				+=========================+		+-----------------+
				|<------| Set lladdr equal old lladdr |		|						|no								|
				|		+-----------------------------+		|						|<-------------------------------
				|				+-------------------+		|						V
				|				| Set errno -EINVAL |<-------				+================+
				|				+-------------------+						|  Is old state  | no
				|						|									| NUD_INCOMPLETE |----->[2]
				|						V									|  or NUD_PROBE? |
				|		+=============================+ yes					+================+
				|		| Is old state not NUD_VALID? |----->[2] 					|yes
				|		+=============================+								V
				|						| no							+==========================+ no
				|						V								| Is new state NUD_FAILED? |---->[2]
				|		+-----------------------------+					+==========================+
				|		| set lladdr equal old lladdr |								|yes
				|		+-----------------------------+								V
				|						|									+--------------------+
				----------------------->|									| Invalid this neigh |
										V									+--------------------+
					 no +=============================+								|
				--------| Is new state NUD_CONNECTED? |								V
				|		+=============================+						+-------------------+
				|						|yes								| Clear notify flag |
				|						V									+-------------------+
				|		+-----------------------------+								|
				|		| Update confirmed timestamps |								V
				|		+-----------------------------+							   [2]
				|						|
				|						V
				|		+---------------------------+
				------->| Update updated timestamps |
						+---------------------------+
								|
								V
					+=========================+ yes  +=====================+ yes  +==========================+
					| Is old state NUD_VALID? |----->| Does new lladdr not |----->|       Is flags not       |
					+=========================+      |  equal old lladdr?  |	  | NEIGH_UPDATE_F_OVERRIDE? |
								|					 +=====================+      +==========================+
								|							|no							|no			|yes
								|							V							|			V
								|					+===================+  				|   +--------------------+
								|				 no |  Does new lladdr  |<---------------	| It is not a router |
								|<------------------| equal old lladdr? |					+--------------------+
								|					+===================+							|
								|							|yes									V
								|							V					+===============================+ no
								|			 no +=========================+		|          Is flags             |--->[2]
								|<--------------| Is new state NUD_STALE? |		| NEIGH_UPDATE_F_WEAK_OVERRIDE? |
								|				+=========================+		+===============================+
								|							|yes								|yes
								|							V									V
								|				+=======================+		+=============================+ no
								|			 no |     Is flags not      |		| Is old state NUD_CONNECTED? |--->[2]
								|<--------------| NEIGH_UPDATE_F_ADMIN? |		+=============================+
								|				+=======================+						|yes
								|							|yes								V
								|							V					+---------------------------------+
								|					+-----------------+			| Set new lladdr equal old lladdr |
								|					|  Set new state  |			+---------------------------------+
								|					| equal old state |							|
								|					+-----------------+							V
								|							|						+-------------------------+
								|							|						| Set new state NUD_STALE |
								|							|						+-------------------------+
								|							|									|
								--------------------------->|<-----------------------------------
															V
										yes	+=================================+
							----------------| Does new state equal old state? |
							|				+=================================+
							|								|no
							|								V
							|						+------------+
							|						| Stop timer |
							|						+------------+
							|								|
							|								V
							|				+=========================+ yes  +--------------+
							|				| Is new state NUD_PROBE? |----->| Set probes 0 |
							|				+=========================+		 +--------------+
							|								|no						|
							|								V						|
							|			 no	+============================+			|
							|		--------| Is new state NUD_IN_TIMER? |<----------
							|		|		+============================+
							|		|						|yes
							|		|						V
							|		|		+=============================+ yes  +--------------------------+
							|		|		| Is new state NUD_REACHABLE? |----->| set timer reachable_time |
							|		|		+=============================+		 +--------------------------+
							|		|						|no									|
							|		|						V									|
							|		|				+-------------+								|
							|		|				| Set timer 0 |								|
							|		|				+-------------+								|
							|		|						|									|
							|		|						V									|
							|		|	+-------------------------------------+					|
							|		--->| Set neighbour state euqal new state |<-----------------
							|			+-------------------------------------+
							|								|
							|								V
							|						+-----------------+
							|						| Set notify flag |
							|						+-----------------+
							|								|
							------------------------------->|
															V
									 no	+=======================================+
								--------| Does new lladdr not equal old lladdr? |
								|		+=======================================+
								|							|yes
								|							V
								|					+---------------+
								|					| Sequence lock |
								|					+---------------+
								|							|
								|							V
								|				+---------------------------+
								|				| Set old lladdr new lladdr |
								|				+---------------------------+
								|							|
								|							V
								|					+-----------------+
								|					| Sequence unlock |
								|					+-----------------+
								|							|
								|							V
								|		+--------------------------------------------+
								|		| Update all cache connected with this neigh |
								|		+--------------------------------------------+
								|							|
								|							V
								|			+=================================+ yes  +-----------------------+
								|			| Is new state not NUD_CONNECTED? |----->| Update confirmed time |
								|			+=================================+		 +-----------------------+
								|							|no									|
								|							|<-----------------------------------
								|							V
								|					+-----------------+
								|					| Set notify flag |
								|					+-----------------+
								|							|
								--------------------------->|
															V
											+=================================+ yes
											| Does new state equal old state? |----->[2]
											+=================================+
															|no
															V
											+=============================+ no +-----------------+
											| Is new state NUD_CONNECTED? |----| neigh_suspect() |
											+=============================+    +-----------------+
															|yes						|
															V							|
													+-----------------+					|
													| neigh_connect() |					|
													+-----------------+					|
															|							|
															|<---------------------------
															|<---------------------------
															V							|
											+=============================+				|
							----------------| Is old state not NUD_VALID? |				|
							|				+=============================+				|
							|								|yes						|
							|								V							|
							|					+=========================+				|
							|					| Is new state NUD_VALID? |				|
							|					+=========================+				|
							|								|yes						|
							|								V							|
							|			+---------------------------------------+		|
							|			| deal with neighbour and route affairs |		|
							|			+---------------------------------------+		|
							|								|							|
							|								|							|
							|								-----------------------------
							|
							---------------------
												|
												V
									+--------------------+
									| Update neigh->flag |
									+--------------------+
												|
												V
										+-----------+
										| Do notify |
										+-----------+


#邻居基础结构的一般任务

下面的三个概念，在对邻居基础结构进行深入的研究之前，必须要搞清楚。

## 缓存

邻居层实现了下面两种形式的缓存

- 邻居映射\
	由于任何数据都有可能被多次使用，那么缓存L3到L2的映射结果就是有意义的。不缓存错误的结果(失败的地址解析)，但是会将失败的neighbour结构设置为NUD_FAILED态，以便垃圾回收定时器能将其清除。
- L2帧头\
	邻居基础结构会缓存L2帧头，这样可以缩短L3封包到L2帧的封装时间。否则，基础结构将要挨个初始化封包的L2帧头的每个字段。

邻居基础结构将neighbour结构放到缓存中，每个协议一个缓存，其结构是典型的hash表结构，同一个bucket中冲突的元素被链接到一个单链表中，新元素被增加到链表的开头(详细参考neigh_create函数)。Hash函数负责吧元素分发到bucket中,它的输入参数是L3地址、关联的设备和一个为了降低假设的拒绝服务攻击的影响而定期重新计算的一个随机数。

查询某个邻居协议的缓存的主要函数是neigh_lookup。除此之外，还有其他两个函数，都是调用neigh_lookup，当查找失败时，根据输入的参数，它们可以选择是否在缓存中强制创建一个neighbour项。下面是对这三个函数的简要介绍:

- neigh_lookup\
	该函数会检查要查找的元素是否存在，并且在查找成功时，返回指向该元素的指针。

		struct neighbour *neigh_lookup(struct neigh_table *tbl, const void *pkey, struct net_device *dev)
		{
			struct neighbour *n;

			NEIGH_CACHE_STAT_INC(tbl, lookups

			rcu_read_lock_bh();
			n = __neigh_lookup_noref(tbl, pkey, dev);
			if (n) {
				if (!atomic_inc_not_zero(&n->refcnt))
					n = NULL;
				NEIGH_CACHE_STAT_INC(tbl, hits);
			}

			rcu_read_unlock_bh();
			return n;
		}
		EXPORT_SYMBOL(neigh_lookup);

- __neigh_lookup\
	该函数调用neigh_lookup。当查找失败，并且该函数的输入参数中设置了create标志时，该函数就使用neigh_create函数来创建一个neighbour项。

		static inline struct neighbour *__neigh_lookup(struct neigh_table *tbl, const void *pkey, struct net_device *dev, int creat)
		{
			struct neighbour *n = neigh_lookup(tbl, pkey, dev);

			if (n || !creat)
				return n;

			n = neigh_create(tbl, pkey, dev);
			return IS_ERR(n) ? NULL : n;
		}

- __neigh_lookup_error\
	该函数调用neigh_lookup函数来查看要查找的邻居项是否存在，并且当查找失败时，总是创建一个新的neighbour实例。除了不需要输入create标识以外，该函数基本上和__neigh_lookup函数相同。

		static inline struct neighbour *neigh_lookup_errno(struct neigh_table *tbl, const void *pkey, struct net_device *dev)
		{
			struct neighbour *n = neigh_lookup(tbl, pkey, dev);

			if (n)
				return n;

			return neigh_create(tbl, pkey, dev);
		}

## 定时器
邻居子系统使用了几个定时器。有些定时器是全局的，而另外一些定时器为每个邻居单独创建。某些定时器的运行是周期性的，也有一些只是在需要的时候才启动。下面对这些定时器进行简单的描述。

- 状态转移定时器(neighbour->timer)\
	一些NUD状态的转移是由时间的推移而触发的，而不是由系统事件触发。这些状态转移包括:
	- 从NUD_REACHABLE态到NUD_DELAY态或者NUD_STALE态。
		当在一段时间内没有送往或者接收自某一邻居的流量，就会发生状态转移，并且邻居子系统自动认为该邻居是不可到达的。
	- 从NUD_DELAY态到NUD_PROBE态或者NUD_REACHABLE态
		在邻居可到达性被怀疑以后，这就是该邻居的下一个状态；此时如果可到达性没有被外部事件所证实，那么该邻居系统必须进行一次明确的探测。该定时器只是简单的检测状态改变所需要的条件，并且处理状态的改变。例如，在TCP提供可到达性认证的时候，就会调用neigh_confirm函数。neigh_confirm函数会更新neighbour结构中的一个新时间戳，但并不改变该邻居的状态，当定时器检测到一个新的时间戳，就会改变该状态。
	每个neighbour结构中的定时器可以控制上述三个状态转移中的两个。当用neigh_alloc函数创建一个neighbour项时，该定时器的回调函数被初始化为neigh_timer_handler函数。
- 失败的邻居请求定时器
	如果在给定的时间内，没有收到邻居请求的应答，那么就再发送一个新的邻居请求。发送邻居请求的最大次数参考neigh_parms->XXX_probes字段，当最后一次请求失败后，相关的邻居项就会被转移到NUD_FAILED状态，之后就会启动垃圾回首来清除该邻居项。
- 垃圾回收定时器(neigh_table->gc_interval)
	用于确保内存不会浪费在没用的数据结构上。其回调处理函数是neigh_periodic_work。详细参考垃圾回收一节。

- proxy定时器(neigh_table->proxy_timer)
	对一个会接收到大量邻居请求的代理来说，推迟请求的处理是有好处的。这个定时器否则延迟处理的时间。参见延迟处理邻居请求一节。

## 引用计数
许多与创建新邻居有关的内核子系统都会在一些数据结构中保存对neighbour结构的引用，例如路由子系统。因此，neighbour结构中包含一个名为refcnt的引用计数器。分别由neigh_hold函数和neigh_release函数对该计数器进行递增递减操作。

引起邻居引用计数递增的事件中，最普通的就是封包的传输。当发出一个封包时，由于相应的sk_buff缓存区中就保留着一个对neighbour结构的引用，所以计数器neighbour->refcnt就要加一，以保证封包的传输完成且没有问题。封包传输完成之后，引用计数就减一。

这是一个短期引用的例子，其他的引用可以持续很长时间，例如，路由缓存表保存的引用。

当一个邻居项因为某些原因需要被删除时(参见与其他子系统的交互一节中neigh_ifdown函数)，并不是立即释放其所占的内存，因为也许某个结构仍然引用它，而是将neighbour->dead字段设置为1,表示该邻居已经停用。之后，垃圾回收定时器就会负责清理参考垃圾回收一节中的解释。

# 创建一个邻居项

和大多数缓存项一样，neighbour缓存项的创建是时间驱动的:当系统需要一个邻居，并且缓存不命中时，就需要创建一个邻居实例。特别当下列事件发生时，就创建一个邻居项。

- 传输请求
	当向一台L2地址未知的主机传输封包时，就需要对改地址进行解析。这是最常见的情况。当目的主机不是发送方的邻居时，解析的L2地址就是下一跳网关的地址，而不是目的主机的地址。

- 收到邻居请求
	由于发送请求的主机在自己的封包中有自己的识别信息，收到请求的主机会假设即将有通信在这两台主机之间产生，于是自动创建一个缓存项，然而以这种被动的方式学习到的信息和用明确的邻居请求获取到的信息不具有相同的权威性。

- 手动添加
	管理员可以通过ip neigh add命令创建一个邻居缓存项(参考邻居的系统管理一节)。

当放生上述时间之一，以及查询邻居子系统的缓存不命中时，邻居协议就试图去解析该地址(通常情况下是发送邻居请求)，并且在每个邻居协议缓存中保存解析到的neighbour项。


## neigh_create

创建数据结构本身用neigh_create函数，它的返回值是指向创建的neighbour结构的指针。

	static inline struct neighbour *neigh_create(struct neigh_table *tbl, const void *pkey, struct net_device *dev);

- tbl\
	表示要使用的协议。如果是IPv4，这个参数就是arp_tbl。

- pkey\
	primary key，表示L3地址。邻居缓存中用作查找关键字。

- dev\
	与要创建的邻居项相关的设备。

新的neighbour结构是用neigh_alloc函数来分配存储空间的，该函数也用于初始化一些参数。

在key_len的帮助下，pkey被复制到数据结构中。key_len是pkey的长度。因为邻居结构这个框架设计与具体的协议无关，但是不同的协议pkey的长度不同，所以就增加一个key_len字段。

由于neighbour项中包括了对net_device结构的引用，所以内核会用dev_hold来对后者的引用计数加一，以此保证该设备在neighbour结构存在时不会被删除。

## 邻居初始化

neighbour结构有两种初始化的方式:协议初始化和设备初始化。

1. 协议初始化\
	协议初始化邻居项调用neigh_table->constructor函数完成，后面讲ARP的时候，会讲解该函数。

		if (tbl->constructor &&>(error = tbl->constructor(n)) < 0) {
			rc = ERR_PTR(error);
			goto out_neigh_release;
		}

2. 设备初始化\
	调用网络设备的驱动程序里面提供的初始化邻居项的函数。

		if (dev->netdev_ops->ndo_neigh_construct) {
			error = dev->netdev_ops->ndo_neigh_construct(dev, n);
			if (error < 0) {
				rc = ERR_PTR(error);
				goto out_neigh_release;
			}
		}

	仍然使用旧的邻居基础结构的设备会使用上面的办法初始化邻居项。

		if (n->parms->neigh_setup &&
			(error = n->parms->neigh_setup(n)) < 0) {
			rc = ERR_PTR(error);
			goto out_neigh_release;
		}


最后neigh_create函数要设置创建的邻居项的confirmed字段，表示该邻居是可到达的。正常情况下，该字段由可到达性证明来更新，并且其值用jiffies表示的当前时间。但在这里，从新建的角度来说，neigh_create函数会把confirmed值减去一小段时间，这样就使得邻居状态能比平常和要有有可到达性证据时，少快点转移到NUD_STALE态。

	n->confirmed = jiffies - (NEIGH_VAR(n->parms, BASE_REACHABLE_TIME) << 1);

一旦邻居被初始化后，就使用邻居协议提供的hash函数将它增加到主要缓存中。


# 删除一个邻居项

## 删除

删除邻居项的主要原因有以下3个:

- 内核企图向一个不可到达的主机发送封包。发生这种情况的原因有很多:该主机以关机、或者它的网线没有插好、或者他是个无线设备但是移动到了信号范围之外、或者他的网络配置出现了问题、或许人为为一台不存在的主机手动建立了缓存项。不管什么原因，邻居子系统察觉到传输不成功时，就像相关的邻居项转移到NUD_FAILED状态。这样就可以使用异步垃圾回收机制清除掉该邻居项，参见异步清理函数neigh_periodic_work函数。

- 与该邻居相关联的主机的L2地址改变了(可能是换了NIC)，但它的L3地址还是原来的。这样一来，该邻居项的L2地址就过时了。一个过时的邻居项必须进入NUD_FAILED态，然后创建一个新的邻居项。

- 该邻居结构存在的时间太长、且内核需要它所占用的内存。因此使用垃圾回收收将其删除，参见同步清理函数neigh_forced_gc函数。

当一个邻居项的引用计数为0时，才会删除该结构。只有neigh_release函数才调用实际执行删除任务的函数neigh_destroy。每次对一个结构的引用释放后，就调用一次neigh_release函数，他会将该结构的引用计数减1。当引用计数变为0时，neigh_release就调用neigh_destroy函数来真正的删除该结构。

	static inline void neigh_release(struct neighbour *neigh)
	{
		if (atomic_dec_and_test(&neigh->refcnt))
		neigh_destroy(neigh);
	}

neigh_destroy完成下列的工作:

1. neighbour->dead是否为1，内核没有出错的话，此时该值为1。

2. 停止还在运行的定时器，内核没有出错的话，此时所有的定时器应该都是关闭的，因为在定时器运行期间，邻居项的引用计数就不为0。

3. 清空使用该邻居项的队列(neighbour->arp_queue)。

4. 释放对外部数据结构的引用。

5. 表示主机使用的邻居项的全局计数器减1。

6. 释放该邻居项占用的内存(将其占用的内存空间返还给内存池)。

## 垃圾回收

和其它的内核子系统类似，邻居子系统也维护着一个定时器，该定时器周期性的运行，党其过期时，就执行某个函数清理不用的数据结构。

邻居基础结构使用的垃圾回收算法有两个主要组成部分:

- 同步清理\
	当邻居基础结构需要分配一个新的邻居项，并且这种专用的内存池已经用完时，内核就立即执行同步清理。

- 异步清理\
	异步清理是周期性执行的，目的是为了删除某段时间内没有用过的邻居项。该段时间的长短是可以配置的

在邻居子系统中使用这种相对比较复杂的回收机制，是因为设计者认为，两种方式比单一方式(例如:当一个邻居项的引用计数为0时，就删除该结构)效率更高。异步清理会释放没有价值的邻居项，同步清理是牺牲一些较少使用的邻居项来释放部分内存。因此，两种清理方式选择符合清理条件的结构的标准是不同的。

异步清理也可以由其它外部子系统触发。例如，当路由子系统无法在其缓存中插入一个新的路由项时，它就会删除没有用的缓存项，这个过程直接导致相应的邻居项也被释放。

调整垃圾回收行为的参数有:

- gc_interval

- gc_thresh1，gc_thresh2，gc_thresh3

- last_flush

- gc_timer

### 同步清理:neigh_forced_gc函数

neigh_alloc函数负责为新的邻居项分配内存空间，在分配之前就会启动同步垃圾回收。在实际内存被耗尽之前，为了决定是否需要进行垃圾回收，neigh_alloc会检查两个变量:gc_thresh2和gc_thresh3。

	entries = atomic_inc_return(&tbl->entries) - 1;
	if (entries >= tbl->gc_thresh3 || (entries >= tbl->gc_thresh2 && time_after(now, tbl->last_flush + 5 * HZ))) {
		if (!neigh_forced_gc(tbl) && entries >= tbl->gc_thresh3) {
			net_info_ratelimited("%s: neighbor table overflow!\n", tbl->id);
			NEIGH_CACHE_STAT_INC(tbl, table_fulls);
			goto out_entries;
		}
	}

当邻居项实例的数目大于gc_thresh3时，neigh_alloc就会强制垃圾回收。如果介于gc_thresh2和gc_thresh3直接，并且上次垃圾回收已过去5秒钟，那么也会执行垃圾回收。

gc_thresh2和gc_thresh3的默认值分别是512和1024。这些值看起来很大，主要是为了支持邻居代理。如果没有邻居代理服务器，通常每个主机只为一些本地主机和路由器创建邻居项，因此邻居项的树木永远不会达到这些极限值。但当使用了邻居代理时，就会有很多主机请求L3地址映射。邻居代理服务器收到一个邻居请求之后，就会给发送方创建一个邻居项。在一个中规模的网络中，这些极限值是相当安全的，并且不可能发生缓存溢出。

同步清理函数会删除缓存hash表中所有的符合条件的元素。同时满足下面两个条件的元素就是符合条件的元素。

- 引用计数为1

- 该元素不是NUD_PERMANENT态。在该状态的元素是静态配置的，因此不会过期。

添加元素使用neigh_create函数，它将元素添加在hash表的bucket列表的开头。

### 异步清理:neigh_periodic_work

每个邻居协议都会有一个gc_interval定时器，它会周期性到期。当定时器到期时，他就调用垃圾回收函数neigh_periodic_work。内核实际上将neigh_table->gc_work字段指向gc_periodic_work。不同的协议通过调用neigh_table->gc_work来实现异步清理工作。

	INIT_DEFERRABLE_WORK(&tbl->gc_work, neigh_periodic_work);

<span id="担任代理"></span>
## 担任代理

在前面的[邻居协议代理](#邻居协议代理)一节中描述了代理的作用，并给出了使用代理的一些例子，还给出了邻居协议决定某个邻居请求是否由代理来处理的条件。下面详细描述代理的具体实现。

邻居基础结构中有许多函数以及数据结构都是成对出现的，唯一区别是他们的名字是否以p开头，例如neigh_lookup和pneigh_lookup。p代表proxy，因为代理截获的地址是用不同的方式处理，有专门的一组函数来负责处理这些地址。

<span id="延迟处理邻居请求"></span>

## 延迟处理邻居请求

由代理负责的邻居请求既可以立即处理，也可以在一段可配置的延迟后处理。引入延迟的主要原因是为了使代理的邻居项的优先级比其对应的主机优先级低。发出请求的主机将第一个应答锁定一小段时间，然后等待另一个应答到来，这样就能够提高该主机的优先级，详细参考普通处理的结尾一节。

延迟的时间是一个介于0到NEIGH_VAR_PROXY_DELAY(具体实现参考pneigh_enqueue函数)的随机数。随机数的使用可以降低多个主机同时发出邻居请求，并导致拥塞的可能性。例如当某个网络掉电了，当其恢复后，网络内的数百台主机会同时启动，此时，所有主机会同时请求同一组服务器或者默认网关的地址。随机数延迟可以消除可能导致的流量峰值。

为了使用延迟，邻居子系统会创建一个保存入口邻居请求的队列和一个定时器，在经过一段设定的延迟后，定时器就会溢出，并且会触发一个函数将队列中的相应的元素(一个元素就是一个邻居请求)取出来，然后处理该元素。

代理的流程可以用下图表示:

			|
			|skb from NIC
			|							skb from proxy_queue
			|<-----------------------------------------------------------------------------------
			V																					|
		+=======+   NIC																			|
		| From? |------------																	|
		+=======+			|																	|
			|				|																	|
			|				V																	|
			|	 no	+=======================+ yes												|
			|<------| Proxy needed/allowed? |--------											|
			|		+=======================+		|											|
			|										|											|
			|										V											|
			|							 no	+===================+ yes							|
			|<------------------------------| Configured delay? |--------						|
			|								+===================+		|						|
			|															|						|
			|															V						|
			|												yes	+================+				|
			|<--------------------------------------------------| Unicast probe? |				|
			|													+================+				|
			|															|no						|
			|							   proxy_queue					V						|
			|							^	|-------|			+------------------+			|
			|				  Max size  |	|-------|			|      Enqueue     |			|
			|				(proxy_qlen)|	|-------|<----------| (pneigh_enqueue) |			|
			|							|	|-------|			+------------------+			|
			V							V	|-------|					|proxy_timer expired	|
	+----------------+													V						|
	| Process packet |											+-----------------------+		|
	+----------------+											| Dequeue and re-inject |--------
																|     (proxy_redo)      |
																+-----------------------+

与处理代理延时相关的主要变量和虚函数有:

- 来自neigh_table(协议参数)
	- proxy_queue\
		邻居请求的缓冲队列，新元素被添加到队尾。当队列达到达到它的最大长度之后，新元素就被被丢弃，该队列不会替换旧元素。
	- peoxy_timer\
		用于执行延时的定时器。定时器由neigh_table_init初始化，默认处理函数是neigh_proxy_process。
	- proxy_redo\
		处理出列请求的函数。
- 来自neigh_parms(设备参数)
	- data[NEIGH_VAR_PROXY_LEN]\
		缓冲区的长度(代理服务器使用)。
	- data[NEIGH_VAR_PROXY_DELAY]\
		定时器的超时时间(发送邻居请求的主机使用)。


每个协议都有一个似有队列(neigh_table->proxy_queue)，该队列被所有使用该协议的NIC共享。使用pneigh_enqueue函数将新元素添加到proxy_queue队列中。proxy_queue是一个经过排序的双向链表，可以让定时器很容易的按照入列的时间顺训处理未决的请求。当pneigh_enqueue要增加一个新的请求时，如果proxy_queue队列已经包含了该请求，该函数会重启定时器。它既可以在当前安排的超时期后溢出，也可以在新元素要求的超时期后溢出，哪个先溢出算哪个。

对于从网络设备上收到的新的邻居请求和从代理队列中出来的邻居请求，linux都使用相同的函数来处理。鉴于此，需要有一个函数来区分下面两类封包。

- 刚刚收到的封包，需要被加入到proxy_queue队列中。
- 一段延迟之后从代理队列中出来的封包。

linux通过在sk_buff缓冲区结构中的一个字段设定一个特殊值来区分这两类封包:skb->stamp。该字段是一个时间戳，当首次接收该封包时，被netif_rx初始化为本地接收时间。之后才调用邻居协议处理函数，因此，协议处理函数访问skb->stamp，得到的的值是一个比较大的数。但是，当一个封包的元素被放进proxy_queue时，它的stamp被设置为LOCALLY_ENQUEUED。这样，当该封包被出列，并被送到邻居协议处理函数时，处理函数就知道该封包来自队列。

### 按设备代理和按目的地址代理

当在一个设备上完全启动代理时，那么状态信息就很简单:该设备只需要关联一个标识，这个标识表明了是否启动了代理。另一方面，按目的地址代理需要保存被代理的地址。这些L3地址(本应该侦听这些邻居请求的主机的地址)保存在hash表neigh_table->phash_buckets中，用pneigh_lookuphanshu去查找。

如同neigh_lookup函数(在缓存一节中介绍)，pneigh_lookup函数有一个输入参数，可以在查找失败时，强制建立一个邻居项。与hash_buckets不同，phash_buckets没有最大容量限制，而且也没有垃圾回收机制，因此给phash_buckets表中的元素设置不同的属性没有意义:这些元素的地址是明确配置为要被代理的，因此，他们一直是有效的，直到再次被指定为不用代理。在IPv4中，这些地址只能手动配置。在IPv6中，在一定条件下可以使用协议配置这些地址。

使用邻居协议可以动态往hash表中添加邻居项，或者使用管理命令静态添加(参见邻居的系统管理)。用pneigh_delete函数可以删除表中的项。

### L2帧头缓存

从一台主机法王另外一台主机的所有封包的L2帧头都是相同的。L3包头可能不同，因此，内核不必为缓存L3包头而操心，但是他要缓存L2帧头。复杂的L2协议的帧头协议可能并不一致，但大部分协议是一致的，例如，Ethernet的帧头。使用L2帧头缓存之后，出口设备的驱动程序必须对其支持。

当向一个目的地发送第一个封包后，驱动程序就将其L2帧头保存在名为hh_cache的专用结构中。如果下一次若有封包发往同一个邻居，只需要从缓存中拷贝一个帧头就可以。hh_cache结构与其他邻居结构之间的联系在主要的数据结构一节中有介绍。该结构更详细的描述参见hh_cache结构一节。

L2帧头缓存和L3的路由子系统缓存有紧密的联系。IPv4路由缓存中的每个dst_entry元素都包含一个指向与下一跳相关的邻居项结构体指针以及一个hh_cache帧头缓存列表。每个邻居可以有多个帧头被缓存，但通常只缓存一个。

下图给出了不同缓存使用的数据结构之间的关系。图中还给出了一些简单场景:两个lan由路由器连接在一起。从主机C来看，通过下一跳路由器可以到达主机A、主机B和路由器。如果主机C已经与上述主机进行了数据交换，那么它的路由缓存中为每个主机保存一个dst_entry结构(也就是路由缓存元素)。正当前面所讲，每个dst_entry包含一个到相关的下一跳地址(本例中就是路由器)对应的邻居项的指针，由于这三个主机(主机A、主机B、路由器)通过同一个下一跳地址都可以到达。所以缓存一个L2帧头就足够了。


			+--------+					+--------+					+--------+
			| Host A |					| Host B |					| Host C |
			+--------+					+--------+					+--------+
				|eth0:55:55:55:55:55:55		|eth0:44:44:44:44:44:44		|eth0:33:33:33:33:33:33
				|10.0.1.100/24				|10.0.1.101/24				|10.0.2.100/24
				V							V							V
		=====================================================	===========================
									eth0:11:11:11:11:11:11 |	 |eth1:22:22:22:22:22:22
									10.0.1.1/24            |	 |10.0.2.1/24
														   V	 V
														 +---------+
														 |  Router |
														 +---------+
	
			Host C => Host A / Host C => Host B / Host C => router
	
			struct dst_entry				struct neighbour
			+------------+					+----------------------+
			| *neighbour |----------------->| ha=22:22:22:22:22:22 |
			| *hh        |-------			| *hh                  |-----
			+------------+		|			+----------------------+	|
								|										|
								|			struct hh_cache				|
								|			+--------------------+		|
								----------->| *hh_next			 |<------
											| hh_refcnt = 4		 |
											| hh_type = ETH_P_IP |
											| hh_output			 |
											| hh_data			 |---
											+--------------------+	|
																	V
											+-------------------+-------------------+------+
											|       saddr       |       daddr       | type |
											+-------------------+-------------------+------|
											| 33:33:33:33:33:33 | 22:22:22:22:22:22 |      |
											+-------------------+-------------------+------+
	Example of caches used with routing

上图中hh_cache的引用计数是4，主机C为主机A、主机B和路由器分别存储一个dst_entry结构体实例，这三个实例共用一个hh_cache，引用计数就为3。三个实例共用一个邻居项，邻居项也会引用hh_cache一次。dst_entry结构中保持的引用和邻居项中保持的引用都是通过neigh_hh_init函数设置的，详细参见路由缓存和L2帧头之间的联系。hh_cache结构的引用计数直接调用atimic_inc来递增。

### 设备驱动程序提供的方法

由于使用了L2缓存，设备驱动程序就必须提供一些函数来将L2帧头保存在hh_cache结构中。相关的函数定义于net_device->header_ops。header_ops中提供了create、parse、cache、cache_update、validate这5个虚函数，这5个虚函数交由驱动程序初始化。具体的内容这里不展开讲述。
。。。。。。。。。。


### 路由缓存和L2帧头缓存之间的联系

当刚刚创建一个邻居项时，neigh->output指向neigh_resolve_output函数，该函数负责将该邻居与一个L2帧头关联。这样，L3层的传输函数(参见邻居协议和L3传输函数的交互)可以透明的进行地址解析。
。。。。。。。。。。。

## 协议初始化和清理
每个邻居协议都有一个初始化函数。如果邻居协议包含在内核中，就在系统启动时执行那个初始化函数，如果协议被编译为模块，则在模块载入时执行初始化函数。和其他内核子系统一样,初始化函数会将该子系统需要的全部资源分配给合适的函数。下面列出linux内核实现的四个邻居协议初始化函数。

|协议|初始化函数|清理函数|所在文件|
|:----|:-----|:-------|:------|
| ARP | arp_init | none | net/ipv4/arp.c |
| Neighbour Discovery(ND) | ndisc_init | ndisc_cleanup | net/ipv6/ndisc.c |
| DECnet | dn_neigh_init | dn_neigh_cleanup | net/decnet/dn_neigh.c |
| ARP over IP | atm_clip_init | atm_clip_exit | net/atm/clip.c |

clip是ARP中的特殊情况，并不是一个独立的协议。因此，它不像其它三个协议，不需要使用neigh_table_init函数向内核注册，但是它通过自己完成初始化(例如:内存池申请)。基本上，它会初始化它的neigh_table结构，并且让ARP协议负责处理这个结构。

下面是这些初始化函数要完成的共同的任务。

1. 用neigh_table_init函数初始化neigh_table结构。
2. 需要的话，在/proc文件系统中注册一组变量。
3. 注册一个协议处理函数。IPv4为ARP协议注册arp_rcv函数。IPv6中的邻居协议是通用协议ICMPv6的一部分，因此IPv6注册ICMPv6协议的处理函数，这个函数调用ndisc_rcv来处理那些必须使用IPv6的邻居协议的ICMPv6消息。

neigh_table_init完成以下工作。

1. 为邻居项分配预备的内存池。
2. 分配一个neigh_statistics结构来收集协议的统计信息。参见neigh_statistics结构一节
3. 分配两个hash表:hash_buckets和phash_buckets。这两个表分别作为本机的邻居缓存和本机代理的邻居缓存。
4. 在/proc/net中建立一个文件，用于转储缓存的内容。文件名来自neigh_table->id。
5. 启动gc_timer垃圾回收定时器。参考垃圾回收那一节。
6. 初始化(但是不启动)proxy_timer代理定时器和相关proxy_queue队列。参考延迟邻居请求一节。
7. 添加neigh_table结构到neigh_tables全局列表中。后者由一个锁保护。
8. 初始化其他一些参数，例如reachable_time。

当一个协议使用模块方式运行，并且模块被卸载时，会调用neigh_table_clear函数来撤销neigh_table_init在初始化时做的工作，并且会清理在协议生存期内分配给该协议的任何资源，例如定时器和队列。

上表给出了调用neigh_table_clear的协议清理函数。IPv4是其中唯一一个不可以被编译成模块的协议，因此不需要清理函数。

##与其它子系统的交互

邻居子系统和其它系统是相互影响的，当发生特定事件时，就会产生或者接受相关通知。下面列出了一些与邻居子系统有关联的其他子系统。

1. 路由\
	路由层的缓存和邻居层的帧头缓存之间的联系参考L2帧头缓存一节。
2. 流量均衡(TEQL，Traffic equalizer)\
	TEQL是一种流量控制的排队规则，可以用IPROUTE2包中的tc命令对其配置。这些特征将一些L3的链路组合在一起，在当给一个目的地传送封包时，循环使用这些链路。对邻居协议的影响是，对单个IP地址(主地址)的解析事实上可能引起多个附属IP地址的解析。
3. IPsec\
	IPsec定义了一系列应用到一个封包(当它被传输时)的变化，这样就能对其加密传输。由于这个原因，在一个链表中将有多个dst_entry结构，但只有子后一个才是指向邻居项的指针。
4. Netfilter(iptables)\
	Netfilter钩子被放在能影响入口封包、出口封包和转发封包的多个地方:和这些在所有流量上的潜在影响一样，Netfilter钩子也会影响邻居层的邻居请求和应答。\
	Netfilter和ARP之间的交互使用三个专用钩子点:NF_ARP_IN、NF_ARP_OUT、NF_ARP_FORWARD。ND与ARP不同，它位于IPv6的上层，因此它可以使用IPv6流量使用的默认钩子来过滤封包，这些钩子有:NF_IP6_PRE_ROUTING、NF_IP6_POST_ROUTING、NF_IP6_LOCAL_IN和NF_IP6_LOCAL_OUT。

### 邻居层产生的事件
当一个邻居被申明是不可到达时，就会进入NUD_FAILED态，邻居层就要执行neigh_ops->error_report函数。该函数会将这个时间通知上层协议。例如，在ARP缓存无效的情况下，就要通知IPv4层。所有通知动作都是由neigh_timer_handler负责的，详细参考定时器一节。

### 邻居层接收的事件
邻居子系统维护的邻居项中，不管什么时候只要邻居项中有一个主要元素(L3地址、L2地址、接口设备)变化了，那么该项也就失效了。此时，内核必须确保邻居协议能够知道这些信息是否发生变化。这个过程由邻居子系统提供的两个函数完成的。

1. neigh_ifdown\
	其它的内核子系统要调用该函数，以通知邻居子系统有关设备和L3地址的变化。L3地址的改变通知由L3协议送出。
2. neigh_changeaddr\
	当一个本地设备的L2地址发生变化时，邻居协议调用该函数来更新协议的缓存。为了得到这个事件的通知，每个协议都可以向内核注册一些接收事件的函数。

#### 使用neigh_ifdown更新
下图总结了能生成邻居协议感兴趣的外部事件的行为和函数。其中主要的事件是:

									IPv4																IPv6
		+------------------------------------------------------------+	+-------------------------------------------------------------------+
		|	+------------------+			+--------------------+	 |	|				( From IPv6 module cleanup function)				|
		|	| fib_netdev_event |-----	----| fib_inetaddr_event |	 |	|	+-----------------+	 +------------------+  +----------------+	|
		|	+------------------+	|	|	+--------------------+	 |	|	| addrconf_notify |	 | addrconf_cleanup |  | inet6_addr_del |	|
		|	NETDEV_DOWN				|	|   NETDEV_DOWN				 |	|	+-----------------+  +------------------+  +----------------+   |
		|	NETDEV_UNREGISTER		|	|	(last address is removed |	|					|			  |				  |					|
		|							V	V	 from dev)				 |	|					|			  |				  |					|
		|					  +----------------+ 					 |	|	NETDEV_DOWN		---------	  |		-----------	(last address	|
		|					  | fib_disable_ip |					 |	|	NETDEV_UNREGISTER		|	  |		|	is removed from dev)	|
		|					  +----------------+					 |	|							V	  V		V							|
		|							  |								 |	|						 +-----------------+						|
		|							  V								 |	|						 | addrconf_ifdown |						|
		|						+------------+						 |	|						 +-----------------+						|
		|						| arp_ifdown |						 |	|								  |									|
		|						+------------+						 |	|								  |									|
		+------------------------------|-----------------------------+	+---------------------------------|---------------------------------+
									   |						+--------------+						  |
									   ------------------------>| neigh_ifdown |<--------------------------
																+--------------+
																		^							  Modele cleanup
																		|		+--------------------------------------------------------+
																		|		|									+------------------+ |
																		|		|				--------------------| dn_neigh_cleanup | |
																		|		|				|					+------------------+ |
																		|		|				V										 |
																		|		|	+-------------------+								 |
																		--------|---| neigh_table_clear |								 |
																				|	+-------------------+								 |
																				|				^										 |
																				|				|					+------------------+ |
																				|				--------------------|   ndisc_cleanup  | |
																				|									+------------------+ |
																				+--------------------------------------------------------+

1. 设备关闭\
	每个邻居项都与一个设备相关联。因此，如果该设备停止运行了，那么所有与之相关的邻居项都要被删除。更确切的讲，该事件不仅表示该设备停止运行，而且还表示要清除该设备上的L3配置，以及要报告L3地址到L2地址的映射是无效的。相反情况，如果系统中添加一个设备，邻居子系统对其并不关心。
2. L3地址改变\
	如果管理员改变了接口的配置，以前通过该接口可到达的主机，现在有可能通过它无法到达。因此，改变接口的L3地址会触发调用neigh_ifdown函数。
3. 协议关闭\
	如果作为模块安装的L3协议从内核中卸载了，那么相关的邻居项将不再使用，必须要删除。例如DECnet中的dn_neigh_cleanup和IPv6中的ndisc_cleanup。由于IPv4不是模块实现，所以它不会从内核中删除，也就没有相应的清理函数。

neigh_ifdown函数，他会浏览所有的邻居项，找到与触发事件的设备相关的结构，然后使其不可再用。(这些不用的结构是不会立即被删除的，因为在邻居子系统内，可能仍然有对他们的引用)。下面列出了neigh_ifdown在每个受影响的邻居项上要执行的主要动作。
1. 停止所有未决的定时器。
2. 将相关邻居项的状态改为NUD_NOARP态，这样试图使用该邻居项的任何封包不再会触发邻居请求。
3. 使neigh->output指向neigh_blackhole，以便丢弃送到该邻居的封包而不是将其提交。参见neigh->output函数的使用。
4. 调用skb_queue_perge，将所有在arp_queue队列中待处理的封包丢弃。在neigh_ifdown把缓存中的与有问题的设备相关的项清理之后，就调用pneigh_ifdown清理代理缓存和代理服务器的proxy_queue队列中的相关项。

#### 使用neigh_changeaddr(netdevice通知链)更新

netdevice通知链会跟踪大量与网络运行相关的时间。邻居协议为了获取netdevice通知链的通知，在其初始化函数(arp_init、ndisc_init等)中会向内核注册。

对邻居子系统来说，最重要的事件是NETDEC_CHANGEADDR，在使用命令改变一个设备的L2地址时，由do_setlink函数产生。类似的命令如下:

	ip link set eth0 addr 11:22:33:44:55:66

当该命令调用neigh_changeaddr函数改变地址时，该函数会扫描缓存中的所有邻居项，并将与要改变地址的设备相关的项标记为停用(dead)。垃圾回收函数会处理这些停用项。

<span id="邻居协议和L3传输函数的交互"></span>

## 邻居协议和L3传输函数的交互
在IPv4子系统中，封包传输的结尾要调用ip_finish_output2函数，该函数将封包传到L2。接下来，我们看这个函数如何与邻居子系统相互影响。在IPv6中有个名称与这个函数类似的函数，执行的任务也类似，只是它要调用ND协议而不是ARP协议。

ip_finish_output2的输入包含有封包数据(但是没有L2帧头)，以及一些其他信息，比如传输使用的设备。skb包含了内核用于判断转发路由的路由表缓存项(dst)，路由缓存项中包含了一个指针，指向下一跳地址(可能是网关地址，也可能之目的主机)相关的邻居项。下图是ip_finish_output2函数的简易执行流程。

														+=========================+
													 no	| Is the L2 header cached | yes
										----------------|     and set in dst?     |------------------
										|				+=========================+					|
										|															V
										V											+---------------------------+
							+===========================+							| Get lock on cached header |
						yes |   Is there a neighbour    | no						+---------------------------+
						----| entry associate with dst? |----										|
						|	+===========================+	|											
						V									|						+-----------------------------+
			+----------------------+						V						| Copy cached header into skb |
			| Return neigh->output |				+-------------+					+-----------------------------+
			+----------------------+				| Drop buffer |									|
													+-------------+									V
															|						+-------------------------------+
															V						| Release lock on cached header |
													+----------------+				+-------------------------------+
													| Return -EINVAL |								|
													+----------------+								V
																						+----------------------+
																						| return hh->hh_output |
																						+----------------------+

如果一个缓存的L2帧头是有效的(hh不是NULL)，就把它拷贝到skb缓冲区中(skb->data用户数据的开头，这里也就是存放L2帧头的位置)。最后，要调用hh_output。

如果缓存的L2真有是无效的，ip_finish_output2就调用neigh->output方法。在前面已经解释过，neigh->output指向的函数是根据邻居项的状态决定的。如果L2地址准备好了，这个函数就可能是neigh_connected，这样就可以正确填充帧头，然后传输封包。否则，neigh->output就有可能被初始化为neigh_resolve_output，这个函数将封包放到arp_queue队列中，然后试着发送邻居请求来解析L3地址。不论封包立即发送还是先被放到arp_queue队列中，ip_finish_output2函数的返回值都一样，表示发送成功。从这之后，封包彻底和L3脱离关系。如果收到邻居应答，邻居子系统就会从arp_queue队列中取出封包

当调用ip_finish_output2时，如果需要的邻居项(dst->neighbour)不存在，就将该封包丢弃。这个条件理论上是不可能的，但是如果确实发生这个异常，邻居程序要能处理。

当一个新的邻居项是NUD_NONE态时，他的状态就改变为NUD_INCOMPLETE态，并且启动定时器。该定时器立刻被初始化为过期，然后定时器处理函数neigh_timer_handler产生一个邻居请求，进行地址解析。

dev_queue_xmit是邻居子系统和流量控制子系统之间的接口，后者位于邻居协议和设备驱动程序之间。

## 排队

邻居请求包和邻居应答包被送到邻居协议处理函数，通常都是立即进行处理。但是，像之前[延迟处理邻居请求](#延迟处理邻居请求)一节中所说的那种情况，代理能够配制成排队等候，延迟处理这些请求。

如果L3发出的封包的目的地L2地址还没有被解析，那么他们就被邻居层临时放到队列中等待地址解析，参见[邻居协议和L3传输函数的交互](#邻居协议和L3传输函数的交互)一节，与此相反，邻居协议自己产生的请求和应答立即就传输。

### 入口队列
当入口封包被放进队列时，所有邻居协议都要执行一些特定的任务。这些任务包括往缓存中增加封包，当收到邻居应答时刷新arp_queue及使用代理的proxy_queue。关于ARP协议执行的任务，在后面会有详细的介绍。

### 出口队列
当发送一个封包时。如果目的L3地址和L2地址之间的关联还没有建立，邻居协议将该封包临时插入到arp_queue队列中(每个协议都有自己的arp_queue，并不是只有ARP协议才有)。如果这个关联被及时建立，该封包就出队列并被发送出去，否则，就将其丢弃。

每个邻居项都有它自己的小的、私有的arp_queue队列，默认情况下，它包含三个元素，但这个队列也可以通过/proc配置为基于设备的队列。因为队列是私有的，而不是被所有的邻居共享，所以当协议收到一个邻居应答时，搜索队列的速度会更快，而且也可以保证更高的正确性。当新元素要被增加到私有队列时，如果没有多余空间，就会将新元素简单替换掉比较旧的元素，参考__neigh_event_send函数。

下面给出了三种常见的情况，为了简化问题，没有考虑代理。

1. 空缓存\
	处理的步骤如下:

																|To:192.168.1.1
															(1)	V
				+---------------+ (2) cache lookup	+---------------------------+
				| 192.168.2.1=?	|<------------------|			ARP				|
				|	========	| (6) add cache		|							|
				|	========	|<------------------|							|
				|	========	| (3)				|-----------+	+-----------|
				|	========	|<------------------| TXhandler |	| RXhandler |
				+---------------+					+---------------------------+
													 (7)|	|(4)		^(5)
														|	V			|
														V				|
												+----------------+
												| dev_queue_xmit |
												+----------------+

	1. L3提交要传送封包的请求，该封包药发往L3地址是192.168.1.1的目的地。
	2. 查询缓存，但缓存未命中，创建该目的地址对应的邻居项。
	3. 临时将封包插入到2中创建的邻居项的缓存队列中。
	4. 发出邻居请求。
	5. 收到邻居应答。
	6. 缓存中增加对应的邻居项。
	7. 队列中等待的封包被发送出去。

2. 地址解析待定\
	处理步骤如下:

																|To:192.168.1.1
															(1)	V
				+---------------+ (2) cache lookup	+---------------------------+
				| 192.168.2.1=?	|<------------------|			ARP				|
				|	========	| 					|							|
				|	========	|					|							|
				|	========	| (3)				|-----------+	+-----------|
				|	========	|<------------------| TXhandler |	| RXhandler |
				+---------------+					+---------------------------+

	1. L3提交要传送封包的请求，该封包药发往L3地址是192.168.1.1的目的地。
	2. 查询缓存。
	3. 地址不再缓存中，但是内核已开始解析地址(发出邻居请求)的工作，因此封包被临时插入队列中，等待相关应答。

3. 完成地址解析\
	处理步骤如下:

																|To:192.168.1.1
															(1)	V
				+-------------------+ (2) cache lookup	+---------------------------+
				|    192.168.2.1=	|<------------------|			ARP				|
				| 11:22:33:44:55:66	| 					|							|
				|	============	|					|							|
				|	============	|					|-----------+	+-----------|
				|	============	|					| TXhandler |	| RXhandler |
				+-------------------+					+---------------------------+
															|(3)
															V
													+----------------+
													| dev_queue_xmit |
													+----------------+

	1. L3提交要传送封包的请求，该封包药发往L3地址是192.168.1.1的目的地。
	2. 查询缓存。
	3. 由于缓存命中，封包就立刻发出去。



# 地址解析协议ARP
前面介绍了邻居基础结构对所有邻居协议提供的通用服务。本章中，我们将看到IPv4使用的ARP协议如何适用邻居基础结构的模块化设计。通用基础结构的出现，使得ARP的设计和实现变得相对简单。本章主要ARP，我们着重说明以下几点:

1. 如何初始化neigh_table结构arp_tbl，使其调整通用基础结构的行为来适应ARP。
2. 如何初始化neigh__parms结构，使其调整通用基础结构的行为来适应ARP(例如，设定定时器超时阈值)。
3. ARP封包(即ARPOP_REQUEST/ARPOP_REPLY)的接受如何与邻居子系统配合，以及solicit方法如何运作。
4. 如何根据设备类型和L3地址的类型(单播，多播或广播)初始化neigh_ops结构。
5. ARP代理如何使用通用基础结构。
6. 如何根据编译选项和对某些特性的明确配置来进一步调节ARP行为。
7. 为了处理特别繁重的负荷，内核如何将一些工作交给用户空间守护进程arpd。
8. ARP和逆向ARP(RARP)之间的关系。
9. ARP会将那些事件通知其他的内核子系统，反之依然。

## ARP封包
下图给出了ARP封包在Ethernet帧中的封装格式。


															|  HW size  |			  |  HW size  |
															|<--------->|			  |<--------->|
		+---------+------------+---------+-----------+------+-----------+-------------+-----------+-------------+
		| HW type | Proto type | HW size | Proto size| Oper | Eth saddr | Proto saddr | Eth taddr | Proto taddr |
		+---------+------------+---------+-----------+------+-----------+-------------+-----------+-------------+
												^						|<----------->|			  |<----------->|
						Ethernet header			|						| Proto size  |			  | Proto size  |
						+---------------+---------------+
						|				|				|
						+---------------+---------------+
								|			ARP packet
								V
			+-----------+-----------+------------+
			| Eth saddr | Eth daddr | Frame type |
			+-----------+-----------+------------+

在linux中使用arphdr结构(include/uapi/linux/if_arp.h)来表示ARP封包。

	struct arphdr {
		__be16	ar_hrd;
		__be16	ar_pro;
		unsigned char ar_hln;
		unsigned char ar_pln;
		__be16	ar_op;
	#if 0
		// Ethernet looks like this: This bit is variable sized however...
		unsigned char ar_sha[ETH_ALEN];
		unsigned char ar_sip[4];
		unsigned char ar_tha[ETH_ALEN];
		unsigned char ar_tip[4];
	#endif
	};

下面介绍ARP封包中每个字段的含义:

1. 硬件类型(hardware type)\
	硬件类型标识符，支持的硬件类型定义于include/uapi/linux/if_arp.h文件中。

		/* ARP protocol HARDWARE identifiers. */
		#define ARPHRD_NETROM	0		/* from KA9Q: NET/ROM pseudo */
		#define ARPHRD_ETHER 	1		/* Ethernet 10Mbps */
		#define>ARPHRD_EETHER	2		/* Experimental Ethernet */
		#define>ARPHRD_AX25		3		/* AX.25 Level 2 */
		#define>ARPHRD_PRONET	4		/* PROnet token ring */
		#define>ARPHRD_CHAOS>	5		/* Chaosnet */
		#define>ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB */
		#define>ARPHRD_ARCNET	7		/* ARCnet */
		#define>ARPHRD_APPLETLK	8		/* APPLEtalk */
		#define ARPHRD_DLCI		15		/* Frame Relay DLCI */
		#define ARPHRD_ATM>		19		/* ATM */
		#define ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id) */
		#define>ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734 */
		#define ARPHRD_EUI64	27		/* EUI-64 */
		#define ARPHRD_INFINIBAND 32	/* InfiniBand */

		/* Dummy types for non ARP hardware */
		#define ARPHRD_SLIP		256
		#define ARPHRD_CSLIP	257
		#define ARPHRD_SLIP6	258
		#define ARPHRD_CSLIP6	259
		#define ARPHRD_RSRVD	260		/* Notional KISS type */
		#define ARPHRD_ADAPT	264
		#define ARPHRD_ROSE		270
		#define ARPHRD_X25>		271		/* CCITT X.25 */
		#define ARPHRD_HWX25	272		/* Boards with X.25 in firmware */
		#define ARPHRD_CAN		280		/* Controller Area Network */
		#define ARPHRD_PPP		512
		#define ARPHRD_CISCO	513		/* Cisco HDLC */
		#define ARPHRD_HDLC		ARPHRD_CISCO
		#define ARPHRD_LAPB		516		/* LAPB */
		#define ARPHRD_DDCMP	517		/* Digital's DDCMP protocol */
		#define ARPHRD_RAWHDLC	518		/* Raw HDLC */

		#define ARPHRD_TUNNEL	768		/* IPIP tunnel */
		#define ARPHRD_TUNNEL6	769		/* IP6IP6 tunnel */
		#define ARPHRD_FRAD		770		/* Frame Relay Access Device */
		#define ARPHRD_SKIP		771		/* SKIP vif */
		#define ARPHRD_LOOPBACK	772		/* Loopback device */
		#define ARPHRD_LOCALTLK	773		/* Localtalk device */
		#define ARPHRD_FDDI		774		/* Fiber Distributed Data Interface */
		#define ARPHRD_BIF		775		/* AP1000 BIF */
		#define ARPHRD_SIT		776		/* sit0 device - IPv6-in-IPv4 */
		#define ARPHRD_IPDDP	777		/* IP over DDP tunneller */
		#define ARPHRD_IPGRE	778		/* GRE over IP */
		#define ARPHRD_PIMREG	779		/* PIMSM register interface */
		#define ARPHRD_HIPPI	780		/* High Performance Parallel Interface */
		#define ARPHRD_ASH		781		/* Nexus 64Mbps Ash */
		#define ARPHRD_ECONET	782		/* Acorn Econet */
		#define ARPHRD_IRDA		783		/* Linux-IrDA */

		/* ARP works differently on different FC media .. so  */
		#define ARPHRD_FCPP		784		/* Point to point fibrechannel */
		#define ARPHRD_FCAL		785		/* Fibrechannel arbitrated loop */
		#define ARPHRD_FCPL		786		/* Fibrechannel public loop */
		#define ARPHRD_FCFABRIC	787		/* Fibrechannel fabric */

		/* 787->799 reserved for fibrechannel media types */
		#define ARPHRD_IEEE802_TR			800		/* Magic type ident for TR */
		#define ARPHRD_IEEE80211			801		/* IEEE 802.11 */
		#define ARPHRD_IEEE80211_PRISM		802		/* IEEE 802.11 + Prism2 header */
		#define ARPHRD_IEEE80211_RADIOTAP	803		/* IEEE 802.11 + radiotap header */
		#define ARPHRD_IEEE802154			804
		#define ARPHRD_IEEE802154_MONITOR	805		/* IEEE 802.15.4 network monitor */

		#define ARPHRD_PHONET		820		/* PhoNet media type */
		#define ARPHRD_PHONET_PIPE	821		/* PhoNet pipe header */
		#define ARPHRD_CAIF			822		/* CAIF media type */
		#define ARPHRD_IP6GRE		823		/* GRE over IPv6 */
		#define ARPHRD_NETLINK		824		/* Netlink header */
		#define ARPHRD_6LOWPAN		825		/* IPv6 over LoWPAN */

		#define ARPHRD_VOID		0xFFFF		/* Void type, nothing is known */
		#define ARPHRD_NONE		0xFFFE		/* zero header length */

2. 协议类型(protocol type)
	L3协议标识符，支持的标识符定义于include/uapi/linux/if_ether.h文件中。

		#define ETH_P_LOOP			0x0060		/* Ethernet Loopback packet */
		#define ETH_P_PUP			0x0200		/* Xerox PUP packet */
		#define ETH_P_PUPAT			0x0201		/* Xerox PUP Addr Trans packet */
		#define ETH_P_TSN			0x22F0		/* TSN (IEEE 1722) packet */
		#define ETH_P_IP			0x0800		/* Internet Protocol packet */
		#define ETH_P_X25			0x0805		/* CCITT X.25 */
		#define ETH_P_ARP			0x0806		/* Address Resolution packet */
		#define>ETH_P_BPQ			0x08FF		/* G8BPQ AX.25 Ethernet Packet>-[ NOT AN OFFICIALLY REGISTERED ID ] */
		#define ETH_P_IEEEPUP		0x0a00		/* Xerox IEEE802.3 PUP packet */
		#define ETH_P_IEEEPUPAT		0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
		#define ETH_P_BATMAN		0x4305		/* B.A.T.M.A.N.-Advanced packet [ NOT AN OFFICIALLY REGISTERED ID ] */
		#define ETH_P_DEC			0x6000		/* DEC Assigned proto */
		#define ETH_P_DNA_DL		0x6001		/* DEC DNA Dump/Load */
		#define ETH_P_DNA_RC		0x6002		/* DEC DNA Remote Console */
		#define ETH_P_DNA_RT		0x6003		/* DEC DNA Routing */
		#define ETH_P_LAT			0x6004		/* DEC LAT */
		#define ETH_P_DIAG			0x6005		/* DEC Diagnostics */
		#define ETH_P_CUST			0x6006		/* DEC Customer use */
		#define ETH_P_SCA			0x6007		/* DEC Systems Comms Arch */
		#define ETH_P_TEB			0x6558		/* Trans Ether Bridging */
		#define ETH_P_RARP			0x8035		/* Reverse Addr Res packet */
		#define ETH_P_ATALK			0x809B		/* Appletalk DDP */
		#define ETH_P_AARP			0x80F3		/* Appletalk AARP */
		#define ETH_P_8021Q			0x8100		/* 802.1Q VLAN Extended Header */
		#define ETH_P_IPX			0x8137		/* IPX over DIX */
		#define ETH_P_IPV6			0x86DD		/* IPv6 over bluebook */
		#define ETH_P_PAUSE			0x8808		/* IEEE Pause frames. See 802.3 31B */
		#define ETH_P_SLOW			0x8809		/* Slow Protocol. See 802.3ad 43B */
		#define ETH_P_WCCP			0x883E		/* Web-cache coordination protocol defined in draft-wilson-wrec-wccp-v2-00.txt */
		#define ETH_P_MPLS_UC		0x8847		/* MPLS Unicast traffic */
		#define ETH_P_MPLS_MC		0x8848		/* MPLS Multicast traffic */
		#define ETH_P_ATMMPOA		0x884c		/* MultiProtocol Over ATM */
		#define ETH_P_PPP_DISC		0x8863		/* PPPoE discovery messages */
		#define ETH_P_PPP_SES		0x8864		/* PPPoE session messages */
		#define ETH_P_LINK_CTL		0x886c		/* HPNA, wlan link local tunnel */
		#define ETH_P_ATMFATE		0x8884		/* Frame-based ATM Transport over Ethernet */
		#define ETH_P_PAE			0x888E		/* Port Access Entity (IEEE 802.1X) */
		#define ETH_P_AOE			0x88A2		/* ATA over Ethernet */
		#define ETH_P_8021AD		0x88A8		/* 802.1ad Service VLAN */
		#define ETH_P_802_EX1		0x88B5		/* 802.1 Local Experimental 1. */
		#define ETH_P_TIPC			0x88CA		/* TIPC */
		#define ETH_P_MACSEC		0x88E5		/* 802.1ae MACsec */
		#define ETH_P_8021AH		0x88E7		/* 802.1ah Backbone Service Tag */
		#define ETH_P_MVRP			0x88F5		/* 802.1Q MVRP */
		#define ETH_P_1588			0x88F7		/* IEEE 1588 Timesync */
		#define ETH_P_NCSI			0x88F8		/* NCSI protocol */
		#define ETH_P_PRP			0x88FB		/* IEC 62439-3 PRP/HSRv0 */
		#define ETH_P_FCOE			0x8906		/* Fibre Channel over Ethernet */
		#define ETH_P_IBOE			0x8915		/* Infiniband over Ethernet */
		#define ETH_P_TDLS			0x890D		/* TDLS */
		#define ETH_P_FIP			0x8914		/* FCoE Initialization Protocol */
		#define ETH_P_80221			0x8917		/* IEEE 802.21 Media Independent Handover Protocol */
		#define ETH_P_HSR			0x892F		/* IEC 62439-3 HSRv1 */
		#define ETH_P_LOOPBACK		0x9000		/* Ethernet loopback packet, per IEEE 802.3 */
		#define ETH_P_QINQ1			0x9100		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
		#define ETH_P_QINQ2			0x9200		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
		#define ETH_P_QINQ3			0x9300		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
		#define ETH_P_EDSA			0xDADA		/* Ethertype DSA [ NOT AN OFFICIALLY REGISTERED ID ] */
		#define ETH_P_AF_IUCV		0xFBFB		/* IBM af_iucv [ NOT AN OFFICIALLY REGISTERED ID ] */

		#define ETH_P_802_3_MIN		0x0600		/* If the value in the ethernet type is less than this value then the frame is Ethernet II. Else it is 802.3 */

		/*
		 *>-Non DIX types. Won't clash for 1500 types.
		 */
		#define ETH_P_802_3			0x0001		/* Dummy type for 802.3 frames */
		#define ETH_P_AX25			0x0002		/* Dummy protocol id for AX.25 */
		#define ETH_P_ALL			0x0003		/* Every packet (be careful!!!) */
		#define ETH_P_802_2			0x0004		/* 802.2 frames */
		#define ETH_P_SNAP			0x0005		/* Internal only */
		#define ETH_P_DDCMP			0x0006		/* DEC DDCMP: Internal only */
		#define ETH_P_WAN_PPP		0x0007		/* Dummy type for WAN PPP frames */
		#define ETH_P_PPP_MP		0x0008		/* Dummy type for PPP MP frames */
		#define ETH_P_LOCALTALK		0x0009		/* Localtalk pseudo type */
		#define ETH_P_CAN			0x000C		/* CAN: Controller Area Network */
		#define ETH_P_CANFD			0x000D		/* CANFD: CAN flexible data rate */
		#define ETH_P_PPPTALK		0x0010		/* Dummy type for Atalk over PPP */
		#define ETH_P_TR_802_2		0x0011		/* 802.2 frames */
		#define ETH_P_MOBITEX		0x0015		/* Mobitex (kaz@cafe.net) */
		#define ETH_P_CONTROL		0x0016		/* Card specific control frames */
		#define ETH_P_IRDA			0x0017		/* Linux-IrDA */
		#define ETH_P_ECONET		0x0018		/* Acorn Econet */
		#define ETH_P_HDLC			0x0019		/* HDLC frames */
		#define ETH_P_ARCNET		0x001A		/* 1A for ArcNet :-) */
		#define ETH_P_DSA			0x001B		/* Distributed Switch Arch. */
		#define ETH_P_TRAILER		0x001C		/* Trailer switch tagging */
		#define ETH_P_PHONET		0x00F5		/* Nokia Phonet frames */
		#define ETH_P_IEEE802154	0x00F6		/* IEEE802.15.4 frame */
		#define ETH_P_CAIF			0x00F7		/* ST-Ericsson CAIF protocol */
		#define ETH_P_XDSA			0x00F8		/* Multiplexed DSA protocol */

3. 硬件地址长度(hadrware size)\
	L2地址长度(字节数)(例如Ethernet为6)。

4. 协议地址长度(protocol size)\
	L3地址长度(字节数)(例如IPv4为4)。

5. 操作码(Oper)\
	支持的标识符定义于include/uapi/linux/if_arp.h文件中。

		#define ARPOP_REQUEST	1		/* ARP request */
		#define ARPOP_REPLY		2		/* ARP reply */
		#define ARPOP_RREQUEST	3		/* RARP request */
		#define ARPOP_RREPLY	4		/* RARP reply */
		#define ARPOP_InREQUEST	8		/* InARP request */
		#define ARPOP_InREPLY	9		/* InARP reply */
		#define ARPOP_NAK		10		/* (ATM)ARP NAK */

	下面详细介绍ARP中使用的里两个基本消息类型。
	- ARPOP_REQUEST\
		在试图将一个L3地址解析为L2地址时，这个消息用作邻居请求。对于一个新的邻居项来说，主机会将该消息发到与设备硬件有关的广播地址。如果要确定一个存在的邻居项，主机会将该消息直接发送到该邻居的L2地址。

		使用邻居请求也可能出于其他原因，例如[免费ARP](#免费ARP)一节讨论的情况。
	- ARPOP_REPLY\
		这个消息是邻居请求的应答。他通常直接发到发出请求的主机。但有时，他也会被发到广播地址:在一台主机改变其配置后，该主机就会这么做，来更新其邻居的缓存。

### ARP封包中的目的地址类型

L3地址类型有单播、广播和多播三种。类型保存在neighbour结构中(neighbour->type)，通过调用inet_addr_type可以确定地址类型。ARP对每个类型的处理如下:

- 单播(Unicast)\
	这是最常见的情况，并且其解析是用ARP的普通邻居请求方法。
- 广播(Broadcast)\
	ARP简单的将L3广播地址直接映射为与具体设备有关的L2广播地址。
- 多播(Multicast)\
	ARP使用函数arp_mc_map从L3多播地址导出L2多播地址。

## ARP事物范例
下图给出了一个ARP事物的简单例子，图中一台主机请求与IP地址10.0.0.4相关的L2地址，并且拥有该地址的主机做出了应答。请求封包中的tha字段为0,表示这个字段应该由应答着填充。下图中发送方硬件地址出现了两次:一次在Ethernet帧头中，一次是在ARP封包中。这两个地址通常是一样的，但也有例外，具体参考[担任代理](#担任代理)一节。在实例一节中有更详细的ARP范例。

		IP=10.0.0.1				IP=10.0.0.2				IP=10.0.0.3				IP=10.0.0.4				IP=10.0.0.5
		MAC=11:22:33:44:55:01	MAC=11:22:33:44:55:02	MAC=11:22:33:44:55:03	MAC=11:22:33:44:55:04	MAC=11:22:33:44:55:05
		+-------+				+-------+				+-------+				+-------+				+-------+
		| HOST1 |				| HOST2 |				| HOST3 |				| HOST4 |				| HOST5 |
		+-------+				+-------+				+-------+				+-------+				+-------+
			^						|(1)					^						^						^
			|						V						|						|						|
		============================================================================================================ LAN
		
		IP=10.0.0.1				IP=10.0.0.2				IP=10.0.0.3				IP=10.0.0.4				IP=10.0.0.5
		MAC=11:22:33:44:55:01	MAC=11:22:33:44:55:02	MAC=11:22:33:44:55:03	MAC=11:22:33:44:55:04	MAC=11:22:33:44:55:05
		+-------+				+-------+				+-------+				+-------+				+-------+
		| HOST1 |				| HOST2 |				| HOST3 |				| HOST4 |				| HOST5 |
		+-------+				+-------+				+-------+				+-------+				+-------+
									^												|(2）
									|												V
		============================================================================================================ LAN
	
	1 Oper:ARPOP_REQUEST, sha:11:22:33:44:55:02, spa:10.0.0.2, tha:00:00:00:00:00:00, tpa:10.0.0.4
	2 Oper:ARPOP_REPLY,   sha:11:22:33:44:55:04, spa:10.0.0.4, tha:11:22:33:44:55:02, tpa:10.0.0.2



<span id="免费ARP"></span>

## 免费ARP

也称无端ARP。一般来说，发出一个ARPOP_REQUEST是由于发送方想和一个IP地址通信，需要找到其对应的L2地址。但有时候，发送方生成一个ARPOP_REQUEST是为了通知接收方一些信息，而不是请求信息。这种封包被称为免费ARP，它通常用在下面列出的情况中:

1. L2地址发生变化。
2. 重复地址探测。
3. 虚拟IP。

下面分别对每种情况进行介绍。

### L2地址发生变化
在需要邻居协议的原因一节中我们已经看到，邻居的L2地址的变化(这会使得网络中其它节点的邻居项失效)如果没有协议的帮助，内核是无法知道的。当L2地址变化后，如果等待旧的L3和L2关联到期，然后强制每个节点启动新的协议事务，这样就要忍受一段短暂黑洞时期，因此提前处罚关联的更新是有意义的。改变了地址的节点通过免费ARP来完成这类更新。

### 重复地址检测
同一个局域网内不应该出现有两台主机有相同的L3地址，但这种情况总会发生，尤其是在一个同时包括静态IP配置和动态IP配置(基于DHCP)的大型网络中最有可能。地址重复的最常见的原因是存在多个地址池重叠的DHCP服务器，以及错误的手工配置。

参考上图的例子。主机A启动之后，将自己eth0接口上的IP配置成10.0.0.4，然后就发出一个请求，询问谁的地址是10.0.0.4。如果同一个子网内没有其它主机配置该地址，主机A就不会收到应答。但是如果主机B也配置10.0.0.4的IP地址，那么它就会对刚才的请求做出应答，这样告诉主机A存在重复的地址。

当然，在大型的网络中，允许主机随即放出ARP封包对整个网络的性能是不利的。相反，正如零地址请求一节所述，DHCP服务器在将一个地址授权给客户端之前，通常会发出请求，检测这个地址是否重复，相对来说，这是一种比较好的解决方案。**修改本地借口上配置的IP地址时，linux内核不会发出任何免费ARP。**

<span id="虚拟IP"></span>

### 虚拟IP
免费ARP另一个常用的地方是允许服务器池中的故障迁移。通常情况下，为了使一个站点有冗余度，该站点除了有一台活跃服务器以外，还有一定数量的配置类似的主机处于备用模式。当活跃服务器由于某些原因宕机之后，与heartbeat定时器相关的一个机制(通过服务器池使用的协议实现)就会检测到这个故障，并启动新活跃服务器的选择。这个新服务器会生成一个免费ARP封包来更新网络中的所有其他主机的ARP缓存。因为新服务器继承了旧服务器的IP地址，发出的ARPOP_REQUEST不会被应答，但所有的接收者会更新他们的缓存。

## 多个网路接口的应答
linux不同寻常的设计:它认为一个IP地址属于一个主机，而不是属于一个接口，尽管管理员总是把IP地址设定在特定的接口上。于是出现了下面的问题:

- 一台linux主机会对地址是配置在其任意接口上的地址的ARP请求做出应答。而不管这个请求是那个接口上收到的。为了使linux的行为好像IP地址是配置在接口上，管理员可以使用后面的[/proc选项](#/proc选项)一节描述的ARP_IGNORE特性。

- 主机可能会遇到ARP flux问题，在这种情况下，与L3地址关联的可能是错误的接口。在下面的内容中会对这个文艺进行描述。

假设在同一个lan中，有一台主机有两块NIC，并且另一台主机向其中一个地址发出一个ARP请求。那么在这两个接口上都会收到请求，并且这两个接口都会做出应答。如下图。

			ARP cache
			+-----------------+
			| 10.0.0.2 ?????? |
			+-----------------+
		
			+------------+							+------------+
			|   HOST A   |							|   HOST B   | eth0:10.0.0.2 MAC:11:11:11:11:11:11
			+------------+							+------------+ eth1:10.0.0.3 MAC:22:22:22:22:22:22
				   | eth0 10.0.0.1				   eth0	|	| eth1
				   V									V	V
		==================================================================
			^   ^   |                                   ^   |   |
			|   |   |  ARPOP_REQUEST: who is 10.0.0.2?  |   |   |
			|   |   -------------------------------------   |   |
			|   | ARPOP_REPLY:10.0.0.2 is 11:11:11:11:11:11 |   |
			|   ---------------------------------------------   |
			|     ARPOP_REPLY:10.0.0.2 is 22:22:22:22:22:22     |
			-----------------------------------------------------
	Figure. The ARP flux problem

收到的两个应答，一个来自正确的L2地址的NIC(eth0),而另外一个属于另一个NIC地址。至于那个地址会进入该主机的ARP缓存是不确定的，与该主机收到的应答先后顺序，以及处理多重应答的方式有关。ARP flux问题可以通过[调整ARP选项](#调整ARP选项)一节描述的特性解决。

<span id="调整ARP选项"></span>

## 调整ARP选项

内核允许用户通过/proc文件系统和变异选项来调整ARP的行为。在后面的[使用/proc文件系统调整邻居性能]()一节中，我们会看到如何配置这些特性的详细介绍，以及它们允许的设置和默认值。这里介绍其中主要几个特性。

### 编译选项

1. ARPD(CONFIG_ARPD)
	这个选项允许用户空间的守护进程处理ARP包，这样做在超大型且流量比较大的网络中，可以提高传输性能。参见[ARPD]()一节。

<span id="/proc选项"></span>

### /proc选项

这个选项中的大部分特性既可以配置为全局的，也可以给每个设备单独设置。在程序代码中使用定义在include/linux/inetdevice.h中的IN_DEV_XXX宏可以启动相应的功能。参考这些宏的定义，就能知道哪些特性是全局的，哪些是局部的(可以为设备单独设置的)。所有的这些宏都以设备的IP配置块(net_device->ip_ptr)作为输入参数，IP配置块可以通过in_dev_get函数得到。

#### ARP_ANNOUNCE

整型，定义了不同的限制级别来决定在某个接口上发送的ARP请求报文中所使用的本地源IP地址。限制级别越高，我们收到ARP响应报文的几率就越高。限制级别越低，表明ARP请求报文中包含的发送方的有效信息就越多。

|取值|含义|
|:---|:----------------------------------------|
|`0`(default) |使用配置在任意一个网络接口上的IP地址。通常就是待发送数据包的源IP地址|
|`1` |一个接口上尽量避免使用不属于数据包中目的IP所在的子网的IP作为ARP请求报文的源IP。当目标主机通过该接口可达即接口IP与目标主机接收报文的接口IP属于同一个子网时(就是同一个LAN内)，这种模式是有用的。在发送ARP请求时，发送host会检查每个接口所属的子网，然后找出与数据包的的目的IP属于同一个子网的接口，将该接口的IP地址作为ARP请求报文的源IP地址。如果找不到这样的接口，那么就按等级2进行。|
|`2` |我们总是会根据数据包来选择一个最好的本地IP地址。这种情况下，我们忽略掉IP报文中的源IP地址，然后选择我们更喜欢用一个与目的主机通信的IP地址。选择这个IP地址：首先我们找出所有输出网卡的IP地址，然后根据这些IP地址获取到相应的子网，再找出包含IP报文中目的IP的那个子网，最后选择这个属于这个子网对应的本地IP地址作为ARP请求报文中的源IP地址。如果找不到合适的本地地址，我们就会选择第一个网络接口上(或者其他网络接口上)面配置的IP地址，我们期望在发送ARP请求报文之后，收到ARP响应报文，甚至有时候，不管我们在ARP请求报文中使用的哪一个IP地址。|


#### ARP_IGNORE

整型，定义了不同的模式来响应ARP请求报文。这些模式主要根据ARP请求中的目的IP地址来区分的。

|取值|含义|
|:---|:-------------------------------|
|0(default) |目的地址是本地任意一个网络接口上面配置的IP地址，就发送ARP响应报文|
|1|只有目的地址是本地输入网卡的IP地址时，才发送ARP响应报文|
|2|只有目的地址是本地输入网卡的IP地址，并且发送方的IP地址与本地输入网卡的IP地址属于同一个子网时，才响应相应的ARP请求报文|
|3|如果本地地址被配置成范围主机(scope host)，就不响应ARP请求报文。只有本地地址被配置成全局(global)地址或者链路(link)地址时，才响应ARP请求报文|
|4-7|保留|
|8|ARP请求报文中的目的IP地址是本地的任何IP地址，都不做响应|

#### ARP_FILTER

布尔型，只要任意一个接口的arp_filter(conf/{all,interface}/arp_filter)设置为TRUE，那么该接口的arp_filter也为TRUE。反之设为FALSE。

|取值|含义|
|:---|:---------------------------------|
|`0(default)`| 内核可以响应其他接口上的 arp 请求。这种做法看起来是错误的，但其实是有意义的，它可以增加成功通信的几率。IP是一个完整的主机所拥有的，而不是被一个具体的接口所拥有，只有在一些复杂的设置(例如负载均衡)中，这种行为才会出现问题。|
|`1`| 允许有多个网络接口接在同一个子网内。对于特定的网络接口收到的ARP请求，该网络接口都会应答，而不管真正的数据包是否会从该网络接口上路由出去(因此，对于这些数据包，必须使用基于源(IP/MAC)的路由来工作)。换句话说，它可以控制哪个网络接口来响应一个ARP请求。|

当一台主机有多个NIC连接到同一个LAN，且配置在同一个IP子网上时，这个选项可以控制一个接口是否对入口ARPOP_REQUEST做出应答。上述情况下，每个NIC会收到一个ARPOP_REQUEST封包的拷贝，通过这个选项你可以只选择一个接口来应答(确定性选择，不是随即选择)。这个选项在使用了IP源路由选项的网络中很有用。

下图是一个例子，当主机A试图解析IP地址10.0.0.1时，主机B的两个接口都会收到ARPOP_REQUEST。由于有两个请求，主机B需要查询路由表，然后只应答其中的一个请求，也就是主机B用于访问发送方IP地址(10.0.0.3)时用的接口上收到的请求。主机B的路由表显示出地址10.0.0.3通过eth0和eth1都是可到达的。但是，路由表查找程序总是返回查找的妈祖条件的第一条结果。


														+------------------------------------------+
														| Host B's routing table                   |
														| 10.0.0.0/24 reachable via interface eth0 |
														| 10.0.0.0/24 reachable via interface eth1 |
														+------------------------------------------+
		
			+------------+									+------------+
			|   Host A   | eth0:10.0.0.3/24					|   Host B   | eth0:10.0.0.1/24
			+------------+									+------------+ eth1:10.0.0.2/24
					|eth0									eth0|	|eth1
					V											V	V
		===========================================================================
				|                                                ^    ^
				|	ARPOP_REQUEST: Who is 10.0.0.1               |    |
				-----------------------------------------------------------

当设置该选项后，只有在内核知道如何到达发送方的IP地址，并且只有到达发送方IP地址的设备是接收入口ARPOP_REQUEST封包的设备时，内核才会处理这个请求。

#### Medium ID
这个特性用于处理某些很少见的情况，IP子网横跨不同的LAN，且该子网中提供ARP代理的主机有多块NIC。如果使用集线器或者交换机将这样的两个网络连在一起，就会出现一种情况:这个代理主机就成了一个不是当的代理，他代替另外一个LAN中的主机响应请求，但那台主机自己能处理请求。

											+------------------------------------------+
											| Host B's routing table                   |
											| 10.0.0.0/30 reachable via interface eth1 |
											| 10.0.0.0/24 reachable via interface eth0 |
											+------------------------------------------+
									LAN3(10.0.0.0/24)
									================
											|
											|
				+--------+					|		+----------------------+ eth0:10.0.0.5/24(medium_id=1)  +--------+
				| Host A |					------->| Host B(peoxy server) | eth1:10.0.0.2/30(medium_id=1)  | Host C |
				+--------+							+----------------------+								+--------+
					|eth0:10.0.0.3/24				eth0|				|eth1									|eth0:10.0.0.1/24
					V									V				V										V
		====================================================================================================================
					|									|				^										^
					|									|				|										|
					---------------------------------------------------------------------------------------------
										ARP_REQUEST:Who is 10.0.0.1?
	Figure. Example of use of medium ID

主机A、B、C在同一个LAN上，主机B有两块NIC接入该LAN，其中eth0用于访问10.0.0.0/24子网内的所有IP地址，eth1只用于和主机C通信，因为他们使用了/30子网。对于LAN1和LAN3，主机B都是作为代理。

假设主机A现在需要向主机C传输一些东西，但是没有其L2地址。主机A就会发出一个ARPOP_REQUEST广播包，主机B的eth0和eth1接口以及主机C都会接受到该封包。主机B不应该对这个ARPOP_REQUEST做出应答，因为主机C自己可以应答。

假设主机B是一个ARP代理服务器，并且在其所有接口上都启动了代理。接下来，分析一下主机B在其两个接口上收到ARPOP_REQUEST包时如何进行处理。

- eth0接口上收到的请求\
	根据路由表，请求解析的地址10.0.0.1通过另一个接口(eth1)可以到达。因此，主机B会处理该请求。注意，主机B有两条路由与目的地址10.0.0.1相匹配，但子网掩码/30的更具体一些，因此就选中这一条。
- eth1接口上收到的请求\
	在这种情况下，接收接口和用于到达10.0.0.1接口是一致的，因此主机B不处理这个请求。

正如前面的例子，需要只用方式来告诉ARP代理服务器，它的两个接口都在同一个广播域内，因此，两个ARP_REQUEST包都不应该被处理。通过给连在同一个LAN上的接口指定一个medium ID的ID就可以解决这个问题。上述情况下，主机B上的eth0和eth1都设为同一个medium ID。对于入口邻居请求，只有当请求解析的地址通过一个设备可以到达，但这个设备的medium ID和入口设备的medium ID不同时，主机才会应答该请求。medium ID是一个正数，下面列出其取值。

|取值|含义|
|:-----|:----------|
| -1 | ARP代理已关闭。|
|0(default)|Medium ID特性已关闭。|
|>0|合法的Medium ID。|

##### arp_fwd_proxy
下图给出了arp_fwd_proxy函数对上述过程的逻辑实现。arp_process会调用这个函数，根据ARP代理和medium ID的配置情况，检查一个ARP请求是否可以被代理。

																				+========================+
																			 no |  Is proxy ARP enabled  |
																----------------| on the ingress device? |
	static inline int arp_fwd_proxy(struct in_device *in_dav,	|				+========================+
					struct net_device *dev, struct rtable *rt)	|							|yes
	{															|							V
		struct in_device *out_dev;								|				+=========================+
		int imi, omi;											|				| Is medium ID configured | no
																|				| on the ingress device?  |--------------
		if (rt->dst.dev == dev)									|				+=========================+				|
			return 0;											|							|yes						|
																|							V							|
		if (!IN_DEV_PROXY_ARP(in_dev))							|			+==================================+		|
			return 0;											|		 yes| Does the medium ID configuration |		|
		imi = IN_DEV_MEDIUM_ID(in_dev);							|<----------|        disable proxy-ARP?        |		|
		if (imi == 0)											|			+==================================+		|
			return 1;											|							|no							|
		if (imi == -1)											|							V							|
			return 0;											|				+=========================+				|
																|			 no | Is proxy ARP enabled on |				|
		/* place to check for proxy_arp for routes */			|<--------------|   the engress device?   |				|
		out_dev = __in_dev_get_rcu(rt->dst.dev);				|				+=========================+				|
		if (out_dev)											|							|yes						|
			omi = IN_DEV_MEDIUM_ID(out_dev);					|							V							|
																|	 no	+==========================================+ yes|
		return omi != imi && omi != -1;							|<------| Is IN dev medium id != OUT dev medium id |--->|
	}															|		+==========================================+	|
																V														V
														+------------------+									+-------------+
														| Request can NOT  |									| Request can |
														|    be proxied    |									|  be proxied |
														+------------------+									+-------------+


## 初始化ARP协议

net/ipv4/arp.c中的arp_init函数完成ARP协议的初始化工作。在[协议的初始化和清理](#协议的初始化和清理)中给出了一个常用协议初始化函数的框架结构。接下来的内容，我们具体分析ARP协议是如何被初始化的。

初始化函数首先生成一个ARP协议结构体对象，然后初始化ARP协议使用的一些其他常用参数，这个工作由neigh_table_init函数完成。下面的一节会重点介绍ARP协议结构体。

	void __init arp_init(void)
	{
		neigh_table_init(NEIGH_ARP_TABLE, &arp_tbl);

		dev_add_pack(&arp_packet_type);
		arp_proc_init();
	#ifdef CONFIG_SYSCTL
		neigh_sysctl_register(NULL, &arp_tbl.parms, NULL);
	#endif
		register_netdevice_notifier(&arp_netdev_notifier);
	}


内核使用dev_add_pack函数来安装一个协议处理函数，下面这几行代码就能明白ARP协议的入口函数是arp_rcv(net/ipv4/arp.c)。

	static struct packet_type arp_packet_type __read_mostly = {
		.type = cpu_to_be16(ETH_P_ARP),
		.func = arp_rcv,
	};

arp_proc_init函数会建立/proc/net/arp文件，读取该文件就可以看到ARP缓存的内容(包括ARP代理的地址)。

若内核支持sysctl，就能依靠函数neigh_sysctl_register创建一个目录/proc/sys/net/ipv4/neigh，用于输出neigh_parms结构的默认调节参数。注意，neigh_sysctl_register函数的第一个输入参数为NULL，在下面的[建立目录](#建立目录)一节我们会看到，NULL表示调用函数(arp_init)想注册为默认目录。

register_netdevice_notifier向内核注册一个回调函数，用于接收设备状态和配置变化的通知。具体请参考[外部事件](#外部事件)一节。

### arp_tbl表
这个ARP协议使用的最基本的也是最重要的一个表，其中包含ARP协议涉及的关键变量。这个结构的类型是neigh_table。在[主要的数据结构](#主要的数据结构)一节对该结构有详细描述。ARP按照如下流程初始化这个表:

	struct neigh_table arp_tbl = {
		.family		= AF_INET,
		.key_len	= 4,
		.protocol	= cpu_to_be16(ETH_P_IP),
		.hash		= arp_hash,
		.key_eq		= arp_key_eq,
		.constructor	= arp_constructor,
		.proxy_redo		= parp_redo,
		.id				= "arp_cache",
		.parms	= {
			.tbl			= &arp_tbl,
			.reachable_time	= 30 * HZ,
			.data	= {
				[NEIGH_VAR_MCAST_PROBES] = 3,
				[NEIGH_VAR_UCAST_PROBES] = 3,
				[NEIGH_VAR_RETRANS_TIME] = 1 * HZ,
				[NEIGH_VAR_BASE_REACHABLE_TIME] = 30 * HZ,
				[NEIGH_VAR_DELAY_PROBE_TIME] = 5 * HZ,
				[NEIGH_VAR_GC_STALETIME] = 60 * HZ,
				[NEIGH_VAR_QUEUE_LEN_BYTES] = 64 * 1024,
				[NEIGH_VAR_PROXY_QLEN] = 64,
				[NEIGH_VAR_ANYCAST_DELAY] = 1 * HZ,
				[NEIGH_VAR_PROXY_DELAY] = (8 * HZ) / 10,
				[NEIGH_VAR_LOCKTIME] = 1 * HZ,
			},
		},
		.gc_interval = 30 * HZ,
		.gc_thresh1 = 128,
		.gc_thresh2 = 512,
		.gc_thresh3 = 1024,
	};
	EXPORT_SYMBOL(arp_tbl);

以reachable_time字段([neigh_parms结构](#neigh_parms结构))为例说明上述各字段在ARP中的重要性。该字段的值表示ARP只有在最后一个可到达性证据在最近的30秒内收到时，才认为这个邻居是NUD_REACHABLE态。

下面的几节中，我们将研究hash、constructor和proxy_redo方法。我们也会看到ARP协议是如何处理入口ARP封包的。

## 初始化neighbour结构

在前面的章节中已经知道，neighbour结构中保存这执行邻居协议任务(对一个L3地址到L2地址映射)的全部信息。每个协议在它的neigh_table->constructor虚函数中指定一个函数来创建neighbour结构。在前面的arp_tbl结构的定义中已经看到，ARP的neighbour结构的初始化函数是arp_constructor。

### 基本的初始化顺序
下图给出了创建一个邻居项的基本步骤。

		+--------------+
		| neigh_create |
		+--------------+
				|			+-------------+
				|---------->| neigh_alloc |
				|			+-------------+
				|
				|			+------------------------------------------------------------+
				|---------->| neigh_table->constructor(protocol sepcific initialization) |
				|			+------------------------------------------------------------+
				|
				|			+---------------------------------------------------------------+
				----------->| neighbour->parms->neigh_setup(Device specific initialization) |
							+---------------------------------------------------------------+
	
	Figure. Initialization sequence for a new neighbour structure

在前面的[创建一个邻居项](#创建一个邻居项)一节，我们看到，创建邻居项的原因不同，那么邻居的初始状态也不同。所以，neighbour结构中的各个字段设置的默认值能被调用这设置的值覆盖。例如，当由于向一个邻居发起传输请求而创建对应的邻居项的时候，neigh->nud_state的值就设为NUD_NONE。但如果用命令行命令创建邻居项，该值可能就是NUD_PERMANENT或者NUD_STALE。广播和多播地址不需要ARP来将其转换为相应的L2广播或多播地址，这些情况下，nud_state的值就是NUD_NOARP。

下面这些字段的初始化尤其重要:

1. nud_state\
	neighbour结构的初始态，根据L3地址的类型和创建该邻居项的原因取值。

2. output\
	根据指定给nud_state的值来初始化output。

3. ha\
	这个字段表示L2地址，也就是ARP协议要发现的地址。[特殊情况](#特殊情况)一节中介绍的地址是不需要ARP的，其L2地址可以直接从其L3地址推导出来。

4. ops\
	[]()这是个虚函数的集合，它决定了IP子系统要调用的动作。下图总结了ARP(确切的说，是arp_constructor)选择neigh_ops实例的标准，从net/ipv4/arp.c中定义的三个neigh_ops中选一个。

		+========================================+ no  +===========================================+ no
		| Device that does not use an L2 header? |---->| Device whose driver can cache L2 headers? |-------------
		+========================================+	   +===========================================+			|
							|yes											|									|
							V												V									V
				+--------------------+								+----------------+					+---------------------+
				| use arp_direct_ops |								| use arp_hh_ops |					| use arp_generic_ops |
				+--------------------+								+----------------+					+---------------------+
		
	Figure. Initialization of neigh->ops in arp_constructor


当neigh_create没有为刚才描述的这些字段指定明确的值时，他们就会继承neigh_alloc函数中指定的值。在neigh_create调用constructor虚函数之前会调用neigh_alloc函数。

<span id="ops字段中的虚函数"></span>

### ops字段中的虚函数

在[L3协议和邻居协议间的通用接口](#L3协议和邻居协议间的通用接口)一节中，我们曾简要介绍了邻居基础结构net/core/neighbour.c文件中提供的函数，那些函数由邻居协议使用output、connected_output、error_report、solicit函数。下面，我们重点讨论上述函数与ARP协议相关的部分。根据邻居的状态，可以被指定给neigh->ops的三组方法是:

1. arp_generic_ops

		static const struct neigh_ops arp_generic_ops = {
			.family =	AF_INET,
			.solicit =	arp_solicit,
			.error_report =	arp_error_report,
			.output =	neigh_resolve_output,
			.connected_output = neigh_connected_output,
		};

2. arp_hh_ops

		static const struct neigh_ops arp_hh_ops = {
			.family = AF_INET,
			.solicit = arp_solicit,
			.error_report = arp_error_report,
			.output = neigh_resolve_output,
			.connected_output = neigh_resolve_output,
		};

3. arp_direct_ops

		static const struct neigh_ops arp_direct_ops = {
			.family = AF_INET,
			.output = neigh_direct_output,
			.connected_output = neigh_direct_output,
		};

关于这三组方法中的每个字段的含义，参考[struct neigh_ops](#struct neigh_ops)。

### arp_constructor函数的启动

arp_constructor的首要任务是从与邻居相关的网络设备中取出一个in_dev结构。这个结构中保存着该网络设备的IP层配置信息。其中也包括ARP的配置信息，如果没有ARP配置信息。该设备也就没有IP配置信息，因此在其上使用ARP也就没有意义，constructor也就终止执行，并返回一个错误。

如果设备中有IP配置信息，arp_constructor经由neigh->parms指针将ARP配置的信息保存在相关的neighbour项中。

接下来的步骤取决于网络设备驱动程序是否提供了L2协议头:dev->hard_header。

	static int arp_constructor(struct neighbour *neigh)
	{
		__be32 addr = *(__be32 *)neigh->primary_key;
		struct net_device *dev = neigh->dev;
		struct in_device *in_dev;
		struct neigh_parms *parms;

		rcu_read_lock();
		in_dev = __in_dev_get_rcu(dev);
		if (!in_dev) {
			rcu_read_unlock();
			return -EINVAL;
		}

		neigh->type = inet_addr_type_dev_table(dev_net(dev), dev, addr);

		parms = in_dev->arp_parms;
		__neigh_parms_put(neigh->parms);
		neigh->parms = neigh_parms_clone(parms);
		rcu_read_unlock();

		if (!dev->header_ops) {
			// case1: Device that doesn't use L2
			
		} else {
			// case2: Device that does use L2
		}
	}

### 不需要ARP的设备

当没有设置dev->hard_header时，表示设备驱动程序没有提供填充L2帧头的函数。也就说设备不需要L2帧头，因此neighbour项的状态应该被设置为NUD_NOARP。此外，neigh_ops应该被初始化为[arp_direct_ops](#ops字段中的虚函数)。arp_direct_ops是neigh_ops结构体的一个实例，该结构中的所有函数都被初始化为dev_queue_xmit:因为不需要邻居协议，arp_direct_ops直接访问底层函数。

		neigh->nud_state = NUD_NOARP;
		neigh->ops = &arp_direct_ops;
		neigh->output = neigh_direct_output;

注意，不必每次在state设置为NUD_NOARP态时，也将neigh->ops设置为arp_direct_ops。有些情况，例如，使用IP广播地址时，L2层会使用一个帧头(dev->hard_header非空),但是不需要ARP。还有，不使用ARP，那么也就不需要初始化neigh->ha，所以它没被初始化。

### 需要ARP设备

IP子系统的广播、多播地址是不需要邻居子系统来解析地址的，回环设备以及设置了IF_NOARP标识的设备也不需要邻居子系统来解析地址。但是，邻居子系统仍需要一个地址来存放L2帧头，下面使用的函数就会指定一个与该设备相关的地址。

	if (neigh->type == RTN_MULTICAST) {
		neigh->nud_state = NUD_NOARP;
		arp_mc_map(addr, neigh->ha, dev, 1);
	} else if (dev->flags & (IFF_NOARP | IFF_LOOPBACK)) {
		neigh->nud_state = NUD_NOARP;
		memcpy(neigh->ha, dev->dev_addr, dev->addr_len);
	} else if (neigh->type == RTN_BROADCAST || (dev->flags & IFF_POINTOPOINT)) {
		neigh->nud_state = NUD_NOARP;
		memcpy(neigh->ha, dev->broadcast, dev->addr_len);
	}

如上图所示，一旦arp_constructor确定某个设备需要ARP，内核就会根据驱动程序来初始化neigh->ops。如果驱动程序提供了管理L2帧头缓存(dev->header_ops->cache)的函数，就使用arp_hh_ops。否则，选择通用函数arp_generic_ops函数。想要知道一个设备是否提供了L2帧头缓存，可以查看与设备相关的xxx_setup函数(例如，对于Ethernet网卡，就是ether_setup函数)。

	if (dev->header_ops->cache)
		neigh->ops = &arp_hh_ops;
	else
		neigh->ops = &arp_generic_ops;

在前面的[基本的初始化顺序](#基本的初始化顺序)一节介绍过，neigh->output的初始化是根据nud_state决定的。例如，当neighbour结构即将被使用时(NUD_VALID态)，output函数就直接初始化为connected_output。关于neigh->output的详细介绍参考[neigh->output使用的函数](#neigh->output使用的函数)。

	if (neigh->nud_state & NUD_VALID)
		neigh->output = neigh->ops->connected_output;
	else
		neigh->output = neigh->ops->output;

## 传输和接收ARP封包

用于发送和接收ARP封包的函数分别是:

- arp_send\
	邻居子系统调用neighbour->ops->solicit来发出邻居请求。在ARP中，solicit函数(arp_solicit)只是对arp_send的简单封装。arp_send负责填充ARP包头和封包内容，并调用dev_queue_xmit函数传送这个ARP请求。

- arp_rcv\
	由于ARP是一个完整功能的协议(和IPv6的ND不同)，因而它要在arp_init中注册一个处理函数。这个函数就是arp_rcv。下一节将详细描述arp_rec函数，以及如何处理两种主要的ARP封包。


如下图所示，ARP封包的传输和接收都可以被Netfilter控制。


							(a)															(b)
							---------------------------------------------------------		| Transmission of
							|														|		| an ARP packet
							|												+----------------------------+
							|												| Fill in header and payload |
							|												|         arp_create         |
							|												+----------------------------+
							|				---------------------					|		|
							|				|	Bridging code	|					V		V
					 +-------------+		|	+-----------+	|			+----------------------+
					 | arp_process |--------|-->| Netfilter |---|--------	|       Netfilter      |(2)
					 +-------------+		|	+-----------+	|		|	+----------------------+
							^				|		(3)			|		|				|
							|				---------------------		V				V
					  +-----------+										+-----------------------+
					  | Netfilter |(1)									|    dev_queue_xmit     |
					  +-----------+										+-----------------------+
							^
							|<---------------------------
							|							|
				+=======================+ yes +===================+					(1) NF_ARP_IN
				| Is the buffer shared? |---->| Make a local copy |					(2) NF_ARP_OUT
				+=======================+     +===================+					(3) NF_ARP_FORWARD
							^
							|
			+==============================+
			|        Sanity check          | failed  +---------+
			| (e.g. Should we process it?) |-------->| Drop it |
			+==============================+         +---------+
							^
							|<---------------------------------
							|								  |
		+========================================+ yes +--------------+
		| Is the ARP frame fragmented in memory? |---->| Linearize it |
		+========================================+     +--------------+
							^
							| Reception of
							| an ARP packet
	
	Figure. (a) arp_rcv (b) arp_send

在arp_rcv和arp_send之间的虚线表明，在某些情况下收到一个ARP封包会导致发出至少一个其他的ARP封包。这些情况是:

- 配置了网桥。收到ARP封包的网桥可能不对其做任何处理，只是转发到其他网桥的接口上。
- 入口的ARP封包是ARP_REQUEST类型，且邻居子系统根据自身的配置决定做出应答。然后邻居子系统就发出ARPOP_REPLY类型的封包。

如上图琐事，arp_send可以有外部事件和少数内核功能(比如，bonding功能)触发，后面的小节对此有详细介绍。


### 发送ARP封包:arp_send介绍

arp_send是ARP用于传输邻居请求和应答的程序，如下图所示。上一章从协议无关的角度，解释了邻居基础结构如何进行邻居请求的发送以及重发送，下面我们看arp_send如何完成这个工作。

		+--------------------+		+----------------------------+		+---------------------------------+
		| Gratuitous request |		| Solicitations(arp_solicit) |		| Replies to request(arp_process) |
		+--------------------+		+----------------------------+		+---------------------------------+
					|							 |										|
					|							 V										|
					|						+----------+								|
					----------------------->| arp_send |<--------------------------------
											+----------+
	
	Figure.Example of contexts wthere arp_send is used

如上图(b)所示，arp_send分为两部分:arp_create初始化ARP封包，arp_xmit在Netfilter中设置钩子，然后调用dev_queue_xmit函数。

arp_send之所以分为两部分，是为了使需要操作封包的驱动程序(比如:在封包中插入附加的头信息)，可以分别调用arp_create和arp_xmit。这样，驱动程序就可以在两个函数之间执行用户定制的任务。例如，如果需要，可以让bonding程序在封包中添加802Q标记(rlb_update_client函数在drivers/net/bonding/bond_alb.c中定义)。

### 邻居请求

在[创建一个邻居项](#创建一个邻居项)一节，我们已经知道内核个会在什么时候生成邻居请求。接下来，我们分析ARP完成这个任务的函数:arp_solicit。

arp_solicit的调用着负责计算探测(发送邻居请求)的次数，并保证还未到达最大值，arp_solicit对此不必关心。

下面是这个函数的原型和其输入参数的含义:

	static void arp_solicit(struct neighbour *neigh, struct sk_buff *skb)

1. neigh\
	L3地址对应的邻居项。
2. skb\
	保存数据封包的缓冲区，该封包的传输将触发产生邻居请求。

要理解arp_solicit函数的实现，理解下面两组参数的关系和区别是很重要的。

1. skb缓冲区中IP头的源IP地址，和arp_solicit选择的要放到ARP头(参见[ARP头格式](#ARP头格式))中的源IP地址。如果封包是本地网络产生的，IP包头中源IP地址就是本地主机的。若封包是要转发的，源IP地址就是最初发送方的。
2. skb缓冲区IP包头中的目的IP地址，和arp_solicit请求解析(neigh->primary_key)的目的IP地址。请求解析的地址是skb下一跳地址(也就是互为邻居)时，IP包头中中的目的IP地址才会和请求ARP解析的地址一致。

arp_solicit的主要任务是:

1. 选择要放到ARP头中的源IP地址。[/proc选项](#/proc选项)一节中提到的ARP_ANNOUNCE选项会影响这个选择过程。下图给出了arp_solicit函数的内部结构，并解释了源IP地址是如何选择的。
2. 更新已经产生的邻居请求的数目。
3. 使用arp_send函数传输请求。

																	0	+====================+ 2
						------------------------------------------------| ARP_ANNOUNCE leval |-------------------
						|												+====================+					|
						|														  |1							|
						V														  V								|
	+============================================+ yes		+============================================+ no	|
	| Is src IP addr in IP hdr local?(RTN_LOCAL) |----  	| Is src IP addr in IP hdr local?(RTN_LOCAL) |----->|
	+============================================+   |  	+============================================+		|
						|no							 |  						  |yes							|
						|							 |  						  V								|
						|							 |		+=============================================+		|
						|							 |	yes | Is src IP addr in IP hdr on the same subnet | no	|
						|							 |	----|     as the target IP?(inet_addr_onlink)     |---->|
						|							 |	|	+=============================================+		|
						|							 V	V														|
						|			+-------------------------------------+										|
						|			| Use sourec address in the IP header |										|
						|			+-------------------------------------+										|
						|																						|
						|																		+----------------------------+
						|																		| Select best source address |
						----------------------------------------------------------------------->| given device and target IP |
																								|     (inet_select_addr)     |
																								+----------------------------+
	Figure. Selection of source IP in arp_solicit

下一节将详细解释如何选择源IP地址。我们先简单说一下其他两个任务是如何实现的。

arp_solicit要区分内核生成的请求和用户空间产生的请求。当ARP守护进程arpd运行时，会发生后一种情况，这要求内核编译的时候选择支持ARPD，详细的论述在[ARPD](#ARPD)一节中。两种方式按照下面的方式处理。

1. 对于内核生成的请求，使用arp_send传输邻居请求。
2. 对于用户空间产生的请求，arp_solicit调用neigh_app_ns来通知相应的用户空间程序:需要生成一个邻居请求。如果内核不支持ARPD，arp_solicit就不做邻居请求，直接返回。

#### ARP_ANNOUNCE和源IP地址的选择

大部分主机只有一个IP地址，因此将其直接拷贝到ARP头中。若一个主机有多个IP地址，ARP_ANNOUNCE的设置就会影响IP的选择。arp_solicit根据ARP_ANNOUNCE的之进行选择。为了完成这个工作，他要利用路由配置子系统提供的三个函数:

1. inet_addr_type\
	在该函数的输入参数中给一个IP地址，他就返回改地址的类型。在ARP中，我们关心的是RTN_LOCAL，它表示这个地址属于本地主机。

2. inet_addr_onlink\
	输入一个设备和两个IP地址，该函数会检查这两个地址是否属于用一个子网。

3. inet_select_addr\
	输入一个设备、一个IP地址(通常不是本地主机的地址)，和一个scope，该函数会在设备信息中查找这个IP地址，该IP地址应该和入口IP地址位于同一个子网中，并且给定的scope比入口IP的scope小、或者相同。典型的是一个站点、一条链路或一个主机。输入地址为0，表示配置在入口设备上的任一主要地址都是符合选择条件的。

注意到，当ARP_ANNOUNCE的级别为0或1，且IP包头中的源IP地址不能使用时，arp_solicit将退回到级别2的分支，调用inet_select_addr函数要用到RT_SCOPE_LINK scope。给定一个设备dev上的IP地址信息，然后从中选出与目的IP地址IP的子网相同的第一个地址，并且选择的scope要大于或等于RT_SCOPE_LINK。

## 处理入口ARP封包
在[初始化ARP协议](#初始化ARP协议)一节已经讲到，ARP注册arp_rcv函数作为其协议处理程序。下面我们来看看这个处理程序如何处理进来的ARP封包。

ARP封包可以从skb缓冲区得到，skb也是函数arp_rcv的输入参数；arp包头就是skb->nh.arph。该函数的首要任务是确保收到的ARP封包不是成碎片的，也就是说内存中的该封包是可以现行访问的。这个任务是必须的，因为有时内存中的skb缓冲区是碎片的，arp_rcv就通过调用函数pskb_may_pull来保证在主缓冲区中有足够的空间，这些用于存放ARP包头和负载。

	if (!pskb_may_pull(skb, arp_hdr_len(dev)))
		goto freeskb;

	static inline int arp_hdr_len(struct net_device *dev)
	{
		switch (dev->type) {
	#if IS_ENABLED(CONFIG_FIREWIRE_NET)
		case ARPHRD_IEEE1394:
			/* ARP header, device address and 2 IP addresses */
			return sizeof(struct arphdr) + dev->addr_len + sizeof(u32) * 2;
	#endif
		default:
			/* ARP header, plus 2 device addresses, plus 2 IP addresses. */
			return sizeof(struct arphdr) + (dev->addr_len + sizeof(u32)) * 2;
		-}
	}

如果满足下面的条件，输入的arp封包就会被arp_rcv丢弃。

1. 收到封包的设备是没有使用ARP协议的设备(也就是说，设备有IF_NOARP标识)。回环接口是一种特殊情况。其发送和接收封包用PACKET_LOOKBACK类型识别。因为这个接口是虚拟的，并没有实际的硬件地址，因此也不需要使用ARP协议。
2. 封包的目的地址不是收到该封包的接口(目的地址不是接收接口的地址或广播地址)。

当缓冲区被共享的时候，其他程序也可以对它进行引用，arp_rcv将用skb_share_check函数克隆一个缓冲区。克隆是很有必要的，因为当处理ARP封包的时候，要保证没有人会改变skb的内容(特别是skb的头指针)。

参见[ARP封包格式](#arp封包格式)一节中有关SIP和TIP的含义，一旦准备对入口ARP封包进行处理，假设Netfilter没有拦截他，arp_process函数就会负责处理。

下图给出了arp_process函数的结构，该函数首先会对他能理解的所有ARP封包类型进行合理性检查，然后根据封包类型执行相应的操作。函数的最后一部分是另一些常用代码，负责更新ARP缓存(如果对应的缓存项没有被锁定)，参见[普通处理的结尾](#普通处理的结尾)。由于对多播IP地址的请求会被丢弃，因为他们是不合规定的。在[特殊情况](#特殊情况)一节我们曾看到，多播地址不需要ARP来转换成链路层地址。

								  +=====================+
								  | Sanity check header |
								  |   fields based on   |
								  |   the device type   |
								  +=====================+
											|passed
											V
							+===================================+
							| Is tip the lookback or multicast? |
							+===================================+
											|no
											|
											V
									+==============+ yes  +===========================+ yes  +=========================+ yes  +----------------+
									| sip=0.0.0.0? |----->| Is operation ARP_REQUEST? |----->| Is tip a local address? |----->| send ARP_REPLY |
									+==============+      +===========================+      +=========================+      +----------------+
								 			|no							|no									|no
											|<---------------------------<-----------------------------------
											V
						ARP_REPLY 	   +===========+ ARP_REQUEST
					-------------------| Operation |-----------------
					|			  	   +===========+				|
					|				  	 	|Other					V
		+-------------------------+			V		   	+--------------------------+
		| see figure ARPOP_REPLY  |	 +-------------+    | see figure ARPOP_REQUEST |
		| handling by arp_process |	 | Drop packet |    | handling by arp_process  |
		+-------------------------+	 +-------------+    +--------------------------+
	
	Figure. arp_process function

### 普通处理的初始化

ARPOP_REQUEST类型和ARPOP_REPLY类型的封包都由arp_process进行处理的。其它任何类型的ARP封包都会被丢弃。目的地址是多播或广播地址的封包也会被丢弃，因为他们不需要ARP。

某些设备类型，只有编译内核时明确指定支持他们，内核才会支持。它们不属于默认设备，因为不会经常使用，因此内核开发者决定将对他们的支持作为可选项，以减小内核的大小。下面给出了switch结构对设备类型挨个判断(使用#ifdef语句保证每个设备以编译进内核)，然后检查对于该设备类型，ARP封包中指定的协议是否正确。这部分代码如下:

	switch (dev_type) {
		default:
			if (arp->ar_pro != htons(ETH_P_IP) || htons(dev_type) != arp->ar_hrd)
				goto out_free_skb;
			break;
		case ARPHRD_ETHER:
		case ARPHRD_FDDI:
		case ARPHRD_IEEE802:
			/*
			 * ETHERNET, and Fibre Channel (which are IEEE 802
			 * devices, according to RFC 2625) devices will accept ARP
			 * hardware types of either 1 (Ethernet) or 6 (IEEE 802.2).
			 * This is the case also of FDDI, where the RFC 1390 says that
			 * FDDI devices should accept ARP hardware of (1) Ethernet,
			 * however, to be more robust, we'll accept both 1 (Ethernet)
			 * or 6 (IEEE 802.2)
			 */
			if ((arp->ar_hrd != htons(ARPHRD_ETHER) && arp->ar_hrd != htons(ARPHRD_IEEE802)) || arp->ar_pro != htons(ETH_P_IP))
				goto out_free_skb;
			break;
		case ARPHRD_AX25:
			if (arp->ar_pro != htons(AX25_P_IP) || arp->ar_hrd != htons(ARPHRD_AX25))
				goto out_free_skb;
			break;
		case ARPHRD_NETROM:
			if (arp->ar_pro != htons(AX25_P_IP) || arp->ar_hrd != htons(ARPHRD_NETROM))
				goto out_free_skb;
			break;
	}

arp_process函数的最后一个任务是初始化ARP头内的变量，这样可以使后续的代码更清晰。

### 处理ARPOP_REQUEST封包
下图给出了arp_process处理ARPOP_REQUEST封包的详细过程。arp_process对本地请求和非本地请求都可以处理。图中的左半部分给出的就是对非本地地址的请求处理，见[ARP代理](#ARP代理)一节。只有下面条件都满足，才会处理ARP_REQUEST封包:


			=====================================================================
			=====================================================================
			=====================================================================
			=====================================================================
			=====================================================================
			=====================================================================
	
	Figure. ARPOP_REQUEST handling by arp_process


1. 内核知道如何访问发送方请求的地址(在路由表中，有一条到该地址的有效路由)。

		if (arp->ar_op == htons(ARPOP_REQUEST) && ip_route_input_noref(skb, tip, sip, 0, dev) == 0) {
			//处理封包
		}

	这是一种对IP地址请求过滤的最简单方式，本地系统并不知道这些地址。若本地系统是一台主机，它只对配置在本地接口上的IP地址的请求做出应答。若该主机是台ARP代理服务器，他会对属于配置在其本地接口上子网内的IP地址的请求做出应答(也就是说，IP地址属于邻居主机)。
	路由子系统会为本地主机的每个IP地址添加一个路由项，为这些IP地址所属的每个子网也添加一个路由项。因此，这些情况下，路由查找程序会过滤掉本地主机不应该应答的请求。

2. 请求的地址既可以属于本地主机，也可以是这个代理服务器能够处理的其他地址。我们使用RT_LOCAL标识请求的地址属于本地地址。[ARP代理](#ARP代理)一节我们介绍远程地址的情况。

3. 没有明确配置来禁止ARPOP_REPLY的传输(参见前面的[ARP_IGNORE](#ARP_IGNORE)和[ARP_FILTER](#ARP_FILTER)两小节)。

如果所有条件都满足，arp_process就调用arp_send，并给其正确的输入参数。在[发送ARP封包:arp_send的介绍](#发送ARP封包:arp_send的介绍)一节有对arp_send的描述。

	if (addr_type == RTN_LOCAL) {
		int dont_send;
		
		dont_send = arp_ignore(in_dev, sip, tip);
		if (!dont_send && IN_DEV_ARPFILTER(in_dev))
			dont_send = arp_filter(sip, tip, dev);
		if (!dont_send) {
			n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
			if (n) {
				arp_send_dst(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip, sha, dev->dev_addr, sha, reply_dst);
				neigh_release(n);
			}
		}
		goto out_consume_skb;
	} else if (IN_DEV_FORWARD(in_dev)) {
		// 参见ARP代理
	}

#### 被动学习和优化ARP
在[创建一个邻居项](#创建一个邻居项)一节提到，在一个ARP事务结束后，请求方和应答方都会学到一些东西。请求方到达从ARPOP_REPLY封包中学到目的地址的目标，这个过程称为主动学习。而收到ARP_REQUEST封包的目的主机从请求封包中也知道了发送方的地址，这个过程称为被动学习。这两个进程可使邻居协议的性能达到最优化。

被动学习由neigh_event_ns负责。该函数会检查是否有一个邻居项和请求这相关联，存在的话就会更新这个邻居项，不存在的话就会创建一个新的邻居项。

不管是更新存在的邻居项还是创建新的邻居项，该函数都有将邻居状态设置为NUD_STALE态。ARP不会采取乐观的措施，将邻居设为NUD_REACHABLE态，因为这个状态是主机已经提供可到达性证明后才能设置。

当neigh_event_ns不能创建邻居项时(通常是因为内存不够、缓存中没有足够的空间)，它就返回NULL。当发生这种情况时，应答也就不会发给请求者。这个策略有点保守，比较积极的方式是根据上述情况做出应答，即使我们暂时无法在我们的系统上为该邻居创建一个邻居缓存项，我们也不应该剥夺它向我们传输数据的能力。

neigh_event_ns要调用[缓存](#缓存)一节介绍的查找函数中的一个。因为当查找成功时，总是会使邻居项的引用计数器加1，而neigh_event_ns需要将该计数器相应减1。

#### 零地址的请求
当一个ARP请求中的源IP地址被设为0(0.0.0.0)时，它就可能是个被破坏的封包，因为0.0.0.0不是一个有效的IP地址。但是也有可能是DHCP用于检测重复地址的特殊封包。参见[重复地址检测](#重复地址检测)一节中关于发送这个封包的条件，以及RFC2131中2.2节关于零地址使用的介绍。

DHCP服务器或客户端可以随意的对DHCP分配的一个IP地址发出一个ARPOP_REQUEST，用于双向检测是否相同的地址被被错误的用在另一台主机上。这种特殊的ARPOP_REQUEST送出时，其源IP地址是0.0.0.0，这样不会给子网内的其它主机引来任何麻烦。

当源IP地址(SIP)为0时，下面的arp_process部分代码就会运行，并在当封包的发送者生成这种请求时，让本地主机申请一个地址。

	if (sip == 0) {
		if (arp->ar_op == htons(ARPOP_REQUEST)
		&& inet_addr_type_dev_table(net, dev, tip) == RTN_LOCAL
		&& !arp_ignore(in_dev, sip, tip))
			arp_send_dst(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip,sha, dev->dev_addr, sha, reply_dst);
		goto out_consume_skb;
	}

### 处理ARPOP_REPLY
如果下列任一条件满足，输入的ARPOP_REPLY封包就会被处理:

1. 存在一个与接受的ARPOP_REPLY相匹配的未决的ARPOP_REQUEST。换句话说，这个ARPOP_REPLY是对内核先前生成的ARPOP_REQUEST的应答，这是最普通的情况。

2. 没有未决的ARPOP_REQUEST，但内核配置了ARP_ACCEPT参数，这时，内核通过调用__neigh_lookup函数创建一个新邻居项，且该函数的最后一个参数不能是NULL。

	n = __neigh_lookup(&arp_tbl, &sip, dev, 0);
	
	if (IN_DEV_ARP_ACCEPT(in_dev)) {
		unsigned int addr_type = inet_addr_type_dev_table(net, dev, sip);
		
		/* Unsolicited ARP is not accepted by default.
		 * It is possible, that this option should be enabled for some
		 * devices (strip is candidate)
		 */
		is_garp = arp->ar_op == htons(ARPOP_REQUEST) && tip == sip && addr_type == RTN_UNICAST;
	
		if (!n && ((arp->ar_op == htons(ARPOP_REPLY)  && addr_type == RTN_UNICAST) || is_garp))
		n = __neigh_lookup(&arp_tbl, &sip, dev, 1);
	}

		==============================================
		==============================================
		==============================================
		==============================================
		==============================================
	
		Figure. ARPOP_REPLY handling by arp_process

撇开封包被接收的原因，已有的neighbour项会被[普通处理的结尾](#普通处理的结尾)一节介绍的通用代码更新，以便反映出ARPOP_REPLY封包中的信息。

### 普通处理的结尾
对于所有的ARPOP_REPLY封包和还没有被处理的ARPOP_REQUEST封包(因为它们不满足[处理ARPOP_REQUEST封包](#处理ARPOP_REQUEST封包)一节中所列出来的条件)，arp_process函数都要执行它最后的代码。

注意，当一个主机对一个ARPOP_REQUEST做出应答时，它会交换ARP头中的源地址和目的地址字段，对于空字段也会填入相应的内容。

在读这些代码时，另一个需要理解的概念是:锁定期。这个概念与内核经常用的加锁的信号量类型没有关系。它只是一种简单的超时机制，负责处理发出一个ARPOP_REQUEST封包收到多个ARPOP_REPLY封包的偶然事件。如果某种配置错误或在同一个LAN中有多个ARP代理服务器，那么就可能发生这种情况。对此，arp_process函数只会对第一个应答做出反应，而拒绝后面的应答。

处理机制如下:邻居子系统在neigh_parms结构中引入data[NEIGH_VAR_LOCKTIME]，该参数可以通过/proc调节。下面的代码设置了override变量，以后它的值就能反映出是否还在锁定期内。如果在锁定期内，只有对某个要更新的邻居项还没有调用过neigh_update函数，才调用该函数更新该邻居项。

最后部分的代码:

	if (n) {
		int state = NUD_REACHABLE;
		int override;

		/* If several different ARP replies follows back-to-back,
		 * use the FIRST one. It is possible, if several proxy
		 * agents are active. Taking the first reply prevents
		 *arp trashing and chooses the fastest router.
		 */
		override = time_after(jiffies, n->updated + NEIGH_VAR(n->parms, LOCKTIME)) || is_garp;

		/* Broadcast replies and request packets
		 * do not assert neighbour reachability.
		 */
		if (arp->ar_op != htons(ARPOP_REPLY) || skb->pkt_type != PACKET_HOST)
			state = NUD_STALE;
		neigh_update(n, sha, state, override ? NEIGH_UPDATE_F_OVERRIDE : 0);
		neigh_release(n);
	}

这些代码必须选择出正确的状态，指定要更新的邻居项。在[可到达性](#可到达性)一节中以讲过，单播应答和广播应答的权限级别不同。单播应答(PACKET_HOST)会设置邻居为NUD_REACHABLE态，而广播应答是设为NUD_STALE态。ARPOP_REQUEST封包出发的更新总是使相应的邻居状态转为NUD_STALE态。

## ARP代理
在[处理入口ARP封包](#处理入口ARP封包)一节中，我们知道了arp_process如何处理对本地地址的请求。现在我们来看arp_process对非本地地址的请求是如何处理的。

我们在[使用代理的条件](#使用代理的条件)以及[按设备代理和按目的地址代理](#按设备代理和按目的地址代理)两节已经知道，内核支持两种类型的代理:基于设备代理和基于目的地址(全局)代理。在一台主机上，其余设备代理默认是关闭的。通过/proc接口既可以启动按设备代理，也可以启动全局代理。内核通过检查include/uapi/linux/ip.h中定义的IN_DEV_PROXY_ARP宏，来确定某个设备上是否启动了ARP代理。全局代理可以通过arp命令或者ip neigh命令来配置(参见[邻居系统的管理](#邻居系统的管理)一节)。

ARP中增加了一个执行代理的条件:目的地址转换(DNAT)。在[DNAT](#DNAT)一节将知道，为什么内核要代理ARP请求。

代理服务器能够处理ARP请求，必须满足一下条件:

1. 在接收封包的设备、或代理服务器所有设备上启动了转发功能。
2. 目的地址是单播地址。
3. 收到ARP请求的设备不是要到达IP地址所使用的设备。

下面的代码来自arp_process函数，展示了arp_process函数如何检查上述几个条件:

	if (addr_type == RTN_LOCAL) {
		//***********
	} else if (IN_DEV_FORWARD(in_dev)) {
		if (addr_type == RTN_UNICAST
			&& (arp_fwd_proxy(in_dev, dev, rt)
			|| arp_fwd_pvlan(in_dev, dev, rt, sip, tip)
			|| (rt->dst.dev != dev
			&& pneigh_lookup(&arp_tbl, net, &tip, dev, 0)))) {
			//*************8
		}
	}

如果上述基本条件都满足，代理程序就要通过配置信息检查是基于设备代理还是全局代理。在前面的[图xxx]()给出了这个检查过程。下面的条件决定了代理服务器是否对请求做出反应。

1. 在某个设备上或所有设备上都启动了代理。
2. [Medium ID](#Medium ID)一节已经讲过，入口接口和出口接口不是同一个介质。
3. 代理过的地址数据库中有目的地址。这个数据库是按照目的地址组织的，并且通过pneigh_lookup函数进行查询操作。

这里假设程序能执行到这一步。

首先，用neigh_event_ns来创建(或更新)发送方IP对应的neighbour结构，参见[被动学习和优化ARP](#被动学习和优化ARP)一节中描述的ARP对本地地址的请求时的处理。

为了防止网络流量的突然增加，代理服务器可以延迟处理ARP请求，参见[延迟处理邻居请求](#延迟处理邻居请求)一节的描述。这样的话，如果封包直接来自另一台主机，并且代理服务器配置了延迟处理，那么该封包就被送到代理队列中。如果封包来自队列，或者没有配置延迟处理，那么就立即处理该封包。

	n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
	if (n)
		neigh_release(n);
	
	if (NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED
		|| skb->pkt_type == PACKET_HOST
		|| NEIGH_VAR(in_dev->arp_parms, PROXY_DELAY) == 0) {
		arp_send_dst(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip, sha, dev->dev_addr, sha, reply_dst);
	} else {
		pneigh_enqueue(&arp_tbl, in_dev->arp_parms, skb);
		goto out_free_dst;
	}

### ARP代理服务器作为路由器

代理和路由器都是对某种功能的扩展，从这个角度上讲，它们看起来是相似的。实际上，IPv4下的路由器通常就是处理ARP代理的主机，IPv6下只允许使用路由器(见RFC2461文档)。但是，代理和路由在下面的问题上还是有区别的:ARP代理服务器对其服务对象来说通常是透明的，而路由器并不是这样。每个主机需要明确配置来使用路由器。在大多数情况下，代理服务器担当这透明路由器的角色，其服务的主机位于不同的LAN中但有着相同的IP子网。如下图所示:

		(a)
		+-------+				+-------+
		|		|				|		|
		+-------+				+-------+
			|eth0 10.0.1.2/25		|eth0 10.0.1.126/25
			V						V
	==========================================
		10.0.1.1/25						^
										|eth0 10.0.1.1/25
									+-------+
							router	|		|
									+-------+
										|eth1 10.0.1.129/25
		10.0.1.128/25					V
	==========================================
			^						^
			|eth0 10.0.1.130/25		|eth0 10.0.1.254/25
		+-------+				+-------+
		|		|				|		|
		+-------+				+-------+
	
		(b)
		+-------+				+-------+
		|		|				|		|
		+-------+				+-------+
			|eth0 10.0.1.2/24		|eth0 10.0.1.126/24
			V						V
	==========================================
		10.0.1.0/24						^
										|eth0 10.0.1.1/25
									+-------+
							router	|		|
									+-------+
										|eth1 10.0.1.129/25
		10.0.1.0/24						V
	==========================================
			^						^
			|eth0 10.0.1.130/24		|eth0 10.0.1.254/24
		+-------+				+-------+
		|		|				|		|
		+-------+				+-------+
	
	(c) 10.0.1.0/24
	==========================================
			^						^
			|eth0 10.0.1.1/24		|eth0 10.0.1.254/24
		+-------+				+-------+
		|		|				|		|
		+-------+				+-------+
	
	Figure. Proxy versus router

(a)给出了一个简单的拓扑结构，两个子网掩码都是/25的子网通过一个路由器进行通信。(b)给出了同样的拓扑中通过代理而不是路由器连接两个子网，只是这两个子网的掩码改为/24，这个变化增加了两个子网10.0.1.0/25和10.0.1.128/25。(c)与(b)等效。

注意，上图中的例子没有建议在ARP代理服务器和路由器之间有限选择哪一个。这两种设备完成的任务是不同的:路由器将子网分为多个LAN，而ARP代理服务器将不同的LAN和并为单一子网。图中提供的例子仅给出了如何改变主机配置，才能使两个子网内的主机通过路由器或者ARP代理服务器通信。当然，你可以将所有的主机都放在一个LAN中，这样就不需要任何路由器和ARP代理服务器。我们这里讨论ARP代理，所以就给出一个使用它的例子。

有一种特殊情况要特别注意:一台ARP代理服务器可以配置成一台透明的默认网关。换句话说，管理员可以让LAN中的主机使用ARP代理服务器来访问默认路由，而不必在每台主机上面配置默认路由。若要实现这个功能，管理员要将主机子网掩码设为/0，在定义默认网关路由时也是使用同样的子网掩码。在这种情况下，ARP代理服务器会处理所有流量未知地址的网络流量，实际上就成了默认网关。ARP代理服务器甚至可以改变自己的地址，而不会对主机产生任何影响，只需要更新主机缓存中所有陈旧的neighbour项即可(参见[免费ARP](#免费ARP)一节)。但是这种看似聪明的方式不是很有效的，下面我会解释其原因。

包含一台ARP代理服务器的网络拓扑结构(类似上图的(b))要记录大量的邻居请求和应答。当要代理的主机数量很多时，邻居请求和应答占用的网络带宽会非常大。

假定有个和图a相似的网络，最坏的情况是/25子网包含了全部126台主机，每台主机需要对其它每台主机进行解析，这样就会产生(126-1)\*(126-1)个不同的邻居请求。但是像这样最坏的情况是很少出现的，因为一台主机通常只访问少数几台机器，例如，服务器。大部分主机的流量要经过路由器，因此所有的主机都需要这个网关路由器的L2和L3地址。

如果我们保持(c)中的网络拓扑结构不变，但当子网掩码由/24改为/0，最坏情况迅速爆发，平均情况开始接近最坏情况。任何时候，主机若想与其它主机通信，不管后者是本地主机还是远程主机，总会产生一个邻居请求。该主机不是生成一个单一的向默认网关(用于访问路由器外的其他主机)的邻居请求，而是必须为每个主机生成一个独立的邻居请求，因为它没有任何的路由器信息。

## 范例

范例拓扑如下图:

		+--------+		+--------+							+--------+			|| LAN3
		| HOST D |		| HOST E |							| HOST X |			||
		+--------+		+--------+							+--------+			||		+--------+
			|10.0.0.2/24	|10.0.0.3/24						|				||<-----| HOST F | 10.0.1.2/24
			V				V									V				||		+--------+
		=============================================================== LAN1	||
		10.0.0.0/24								^								||
												|10.0.0.1/25					||		+--------+
												|								||<-----| HOST G | 10.0.1.3/24
										+--------------+ eth2					||		+--------+
										| Proxy router |----------------------->||
										+--------------+ 10.0.1.1/24			||
												|								||
												|eth1 10.0.0.129/25				||
												V								||
		=============================================================== LAN2	||
			^				^									^				||
			|10.0.0.130/24	|10.0.0.131/24						|				||		+--------+
		+--------+		+--------+							+--------+			||<-----| HOST Z | 10.0.1.4/24
		| HOST A |		| HOST B |							| HOST Y |			||		+--------+
		+--------+		+--------+							+--------+			||
	
	Figure. Example of network with proxy arp configured on host RT

我们首先做如下假定:

1. 所有的主机都使用Ethernet接口卡。
2. LAN1和LAN2中所有的主机配置为相同的子网掩码/24。在他们的路由表中没有任何的路由，也没有配置默认网关。换句话说，在LAN1和LAN2中的主机只能和同一个逻辑子网内的主机通信。
3. 所有主机的邻居缓存都是空的，也就是说，任何主机都不知道其他主机的链路层地址。

注意，尽管LAN1和LAN2中的主机不属于同一个LAN，但他们可以有相同的逻辑子网配置。这种配置的意思是，不同LAN中的主机可以共享同一个子网，并且不需要路由器的帮助就能通信。但是图中的网络拓扑来说，没有RT的帮助，他们是无法交流的。

对于LAN1和LAN2中的主机来说，RT给他们造成了属于同一子网的幻觉，因此RT需要其他的信息:它要合并的LAN的真实子网掩码应该是/25。如果RT不是一台ARP代理服务器，那么RT或者LAN1和LAN2中的主机都属于配置错误。

RT为了让LAN1和LAN2中的主机可以透明通信，它需要有关此网络拓扑结构的更多信息，以及要确切知道每台主机的位置。比较简单的解决方式是，RT将其中的一个LAN内收到的任何封包都转发到另一个LAN内，这种方式和代理无关。对于来自LAN2的请求，如果RT想代表LAN1中的主机(例如，代替其应答)，那么他就需要知道每个主机位于哪个LAN中。例如，RT不应该对LAN1中产生的，且地址是LAN1中的其他主机的请求做出应答。如果RT的eth1和eth2接口上有正确的子网掩码，所以他就知道:

- 在eth0上，主机的地址范围是从10.0.0.1到10.0.0.126。
- 在eth1上，主机的地址范围是从10.0.0.128到10.0.0.254。

当从一个子网到另一个子网转发封包时需要路由器(也就是说，发送方和接收方不再同一个子网内)。注意，如果图中的RT路由器没有启动ARP代理功能，那么他的两块能到LAN1和LAN2的NIC上面的配置就是错误的。

现在开始分析一些ARP请求的常见情况。

1. 从LAN1到LAN1，例如从主机D到主机E\
	由于主机D和主机E在同一个子网内，他就可以发出一个对IP地址10.0.0.3的邻居请求。在LAN1中的所有主机都会收到该请求，但只有主机E会向主机D应答，表明自己的L2地址。注意，尽管RT在eth0上已启动了代理功能，但RT不会应答。原因是RT在eth0(LAN1)上收到邻居请求封包，但他知道10.0.0.3位于发送方的子网内，因此不需要拦截该请求:主机E所处的网络，正是邻居请求生成的网络，因此主机E自己可以应答。

2. 从LAN1到LAN1中的非法IP地址(例如，从主机D到10.0.0.128)\
	从A的角度看，10.0.0.28是一个合法的主机地址:从RT的角度看，它不是一个合法的主机IP地址，他是eth1接口上的网络地址。没有人会做出做出这个应答，不管RT是否是代理。

3. 从LAN1到LAN2(例如，从主机D到主机A)\
	由于主机A在另一个LAN中，他不会收到这个请求并应答。但是，由于RT在eth0上配置了代理功能，他会用eth0接口的地址应答。这表示当主机D要往主机A发送数据是，它实际上是发送到了RT，然后RT再转发到主机A。如果是主机A请求主机D的地址，就是相反的过程。

4. 从LAN1到LAN3(例如，从主机D到主机F)\
	由于主机F和主机D不再同一个子网内，且在主机D中没有定义访问LAN3的路由，于是其内核的IP层会用一个消息作为应答，该消息表明没有到达主机F的可用路由。主机D甚至不会产生邻居请求。

## 外部事件
当满足一定的条件时，ARP就可以就接受和生成通知。在前面的[邻居协议和L3传输函数的交互](#邻居协议和L3传输函数的交互)一节中，曾简要介绍了邻居协议如何与内核的其他部分进行交互，下面我们看具体到ARP协议是如何管理这些通知的。

### 收到的事件
在[初始化ARP协议](#初始化ARP协议)一节已经看到，ARP为了能够得到事件的通知，要向内核注册一个函数。这个函数就是arp_netdev_event，他负责处理这些事件。在该函数接收到的各类事件中，ARP只对NETDEV_CHANGEADDR类型的事件感兴趣。当一个设备的L2地址发生变化的时候(例如手工修改该地址)，内核就会产生该事件。内核中处理用户空间请求改变设备链路层地址的函数是do_setlink。它是发出NETDEV_CHANGEADDR通知的地方，该函数定义在net/core/rtnetlink.c中。

	static int arp_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)
	{
		struct net_device *dev = netdev_notifier_info_to_dev(ptr);
		struct netdev_notifier_change_info *change_info;
	
		switch (event) {
		case NETDEV_CHANGEADDR:
			neigh_changeaddr(&arp_tbl, dev);
			rt_cache_flush(dev_net(dev));
			break;
		case NETDEV_CHANGE:
			change_info = ptr;
			if (change_info->flags_changed & IFF_NOARP)
			neigh_changeaddr(&arp_tbl, dev);
			break;
		default:
			break;
		}
	
		return NOTIFY_DONE;
	}

在[邻居层接收的事件](#邻居层接收的事件)一节中，有对neigh_changeaddr函数的介绍。

为了强制IP层使用新的L2地址，rt_cache_flush函数会刷新IPv4的路由缓存。该函数不是有选择地删除与产生通知的设备关联的缓存项，而是完全清除整个缓存。

### 产生的事件
在[邻居层产生的事件](#邻居层产生的事件)中提到了虚函数error_report，它是neigh_ops结构的一部分。在ARP中，该函数由arp_error_report实现。当一个ARP事务失败时，ARP子系统就会调用该函数。它的两个主要任务是:

1. 从路由缓存表中删除与不可到达的邻居相关的缓存项。
2. 用一个ICMP UNREACHABLE消息通知发送方邻居不可到达。

### 网络唤醒事件
一些高级的NIC设备能够提供称为网络唤醒的功能。

网络唤醒通过给NIC发送一个特殊类型的帧，就能使它唤醒一个处于待机模式的系统。在各种帧的类型中，有唤醒功能的只有ARP帧。该功能是在硬件级别实现的，因为当系统还在待机模式，CPU上没有运行能处理输入封包的设备驱动程序。带有网络唤醒功能的NIC需要有其自己的电源输入，以便能够扫描到这些特殊的帧。这部分功能完全由NIC的驱动程序实现。

## ARPD
在一个网络中，邻居的数量可能会是几个，也会是上千个。因此，在一个大型网络中，邻居数据结构需要的内存也会相当大，并且会影响系统的性能。增大neigh_table结构中的gc_threshn的值只会简单改变创建邻居项的最大数目，而不会解决内核过量消耗内存到来的性能问题。

Arpd是一个用户空间守护进程，可以将ARP负载从内核转移到它自己的(更大些)缓存中。ARP用户空间的实现不可能像内核空间实现的速度一样快，但是大多数情况下，这种速度差别是可以接受的。

使用ARPD，要求内核编译时必须支持ARPD功能。ARPD守护程序是IPROUTE2程序包的一部分。

ARPD守护进程负责拦截来自其它系统的ARP请求，并且维护自己的数据库，以代替内核缓存。下面我们讨论该程序的内部结构，我们的重点在改程序和内核程序的交互上。arpd自己维护和网络的联系。内核也可以继续处理arp请求，并且负责通知arpd自己知道的一些事情。他们两者之间的通信使用netlink套接字。下图给出了邻居子系统ARP和arpd之间的交互关系。本质上，邻居子系统给守护进程发送通知,守护程序会监听这个通知。下面两小节将会介绍这种交互过程。

			+-------+			+------+
			| cache |<--------->| ARPD |
			+-------+			+------+
									^
									|
									V
						+----------------------+		User space
		================|        netlink       |==================
						+----------------------+		Kernel space
							^		^		^
							|		|		|
				RTM_GETNEIGH|		V		|RTM_NEWNEIGH
				+-----------|---------------|---------------+
				| +--------------+     +------------------+ |
				| | neigh_app_ns |     | neigh_app_notify | |
				| +--------------+     +------------------+ |
				+-------------------------------------------+
									^
									|
									V
					+-------+	 +-----+
					| cache |<-->| ARP |
								 +-----+
	
	Figure. Interaction between ARP and daemon

### 内核方面
当启动ARPD功能后，邻居子系统就会给用户空间的守护进程发送消息。下面我们回顾一下用于发送这些消息的相关函数，以及调用这些函数的条件:

1. neigh_app_ns\
	当内核发出的邻居请求封包的数目达到内核允许的最大值，而用户空间生成的邻居请求封包树木还没达到用户空间允许的最大值时，来自协议的请求函数(arp_solicit)就调用这个函数。使用arpd程序的规则是内核在调用该守护进程前，必须用完对某一地址探测的尝试次数。但是，管理员可以通过配置ARPD，使内核更本不产生任何探测，立即调用arpd。

	neigh_app_ns生成的消息类型是RTM_GETNEIGH。

2. neigh_app_notify\
	这个函数用于发送出下面两种通知:
	- 一个neighbour已经被移动到NUD_FAILED态，不久之后就会被垃圾回收器删除。这种情况下，这个状态的变化和对neigh_app_notify的调用是由neigh_periodic_timer处理的。
	- 一个邻居的状态从一个有效态(NUD_VALID)变为一个无效态，或者邻居的L2地址发生变化时，由neigh_update函数来处理状态的变化和调用neigh_app_notify。
	neigh_app_notify函数生成的消息类型是RTM_NEWNEIGH。

### 用户空间方面
从前面一节我们知道了内核什么时候会向arpd发出通知。现在我们来看看arpd如何处理通知。下面是这个守护进程结构框架(main函数)。

1. 获取命令行参数。
2. 打开数据库。
3. 如果选项支持从文件中打开数据库的话:\
	3.1 创建套接字1接收或者发送ARP封包。\
	3.2 创建套接字2接收内核通知。\
4. 无限循环。\
	4.1 监测这两个套接字。\
	4.2 如果在套接字1有输入，那就处理入口ARP封包。\
	4.3 如果在套接字2有输入，那就处理内核消息。\

下图给出了上述行为的一个简单模型((a)代表4.2，(b)代表4.3)。图中也给出了上一节中介绍的内核的相应行为。

守护进程有一些命令行选项，用以调整其行为。例如，管理员可以通过这些选项指定:

1. 在发出多少个探测封包之后，放弃探测该地址。
2. 内核是否应该发出探测封包，还是只有守护进程可以探测封包。
3. 从一个文件中加载邻居项到缓存。

当前的arpd守护进程的ARP缓存实现是用通用的Berkeley DB数据库，这也是管理员在安装IPROUTE2包时，要解决Berkeley DB依赖性的原因。

这里需要提一下arpd程序和内核的ARP子系统之间的一个区别:arpd缓存和内核的ARP缓存不同，arpd缓存中保存否定的结果。当解析一个地址的尝试失败时，arpd守护程序就将其信息保存在它的缓存中，并且在一定时间内不再试图对其进行解析。

## 逆向地址解析协议

RARP是一个旧协议，用于自动配置一台动态主机。他的功能后来被bootp和DHCP替代。尽管RARP的目的和ARP的不同，但RARP也使用了ARP包(ARPOP_REQUEST和ARPOP_REPLY中的操作码不同)，并使用相同的操作函数arp_send。linux内核默认并不包括RARP协议，在编译内核时必须要明确指定才支持该协议。

##ND对ARP的改进

前面的小节已经讲到，IPv6邻居协议ND和ARP是完全不同的设计。下面列出了ND中的一些改进。

1. ND是ICMPv6提供的一个函数。ICMPv6是一个强大的覆盖了ICMPv4、ARP和其他功能的协议。如同在[邻居协议](#邻居协议)一节中讲的，ND集成在ICMP中使得ND可以充分利用任何L3的特性，特别是加密功能。

2. ND使用多播邻居请求而不是广播。使用的多播地址来源于要请求的目的地址，表示只有注册到给定的IP多播地址的主机才接收相应的邻居请求。在一个大型网络中，这种方式可以显著的减少主机接收和丢弃邻居请求的数量，丢弃的原因是主机不是收到邻居请求的目的地。

3. ND使用邻居不可到达检测算法来检测停用的邻居。并不是每个ARP实现都使用了该算法，但是linux的ARP实现了该算法。


#arp_process() 处理流程
	(1) 从 skb 中获取网络设备。struct net_device *dev = skb->dev。
	(1) 从网络设备中获取 ipv4 的配置，存在 struct in_device *in_dev。
	(1) 获取接口设备硬件类型。u16 dev_type = dev_type。

	(1) ARP 使用什么样的硬件类型就决定了使用什么样的协议类型，两者必须匹配。

(2) 包中的协议字段必须为 1(请求) 或者 2(发送)。

(3) 获取 sip(source ip address), tip, sha(source hard address)。

(4) 不回复 ARP 包的两种情况。
	(a) tip 是回环地址：回环地址绑定在虚拟的回环设备上，该设备并没有实际的 MAC 地址，所以不需要回复 ARP REQUEST 包。
	(b) tip 是多播(组播)地址：多播地址的接收方可能是一个或者多个，假设 A B C 三台主机，A 发送了一个多播 ARP 包，B C 都会接收到该报文，可是谁回复呢？回复之后主机 A 的 ARP 缓存该存谁的 MAC 地址呢？显然，谁回复都不好，干脆就不回复了。

(5) sip 与 tip 相同(免费 ARP)的情况下，如果 IPV4_DEVCONF_DROP_GRATUITOUS_ARP 不为 0[\[参见\<net/ipv4/devinet.c\> (static struct ipv4_devconf ipv4_devconf = {})\]]()，丢弃该包 。免费 ARP 一般有两个用途：1.一台主机可以通过免费 ARP 确认是否有另外一台主机设置了相同的 IP。2.一台主机的硬件地址改变(比如更换网卡)，可以通过免费 ARP 通知其它主机更新 ARP 缓存。

(6) 帧中继操作[\[参见 Q.922 文档\]]()

(7) **看不懂，与路由相关**

(8) sip 为 0.0.0.0。DHCP 网络中，client 和 server 都可以发送 sip 为 0.0.0.0 的 ARP 包，用来进行重复地址检测。
	(a) 收到的包是 ARP 请求包，其中的 tip 和本机位于同一个 LAN 内，接受的设备上面配置的 ARP_IGNORE 值合法。
		(A) 发送 ARP 应答包
	(b) ==>>[out_consume_skb]
(9) 收到的是 ARP 请求包，且路由查找(ip_route_input_noref())结果为 0?[>>(a)]:[>>(10)]
	(a) 从 skb 中获取路由缓存标 rt，获取缓存标 rt 的地址类型 addr_type。
	(b) addr_type 为 RTN_LOCAL?[>>[1]]:[>>(c)]
		[1] in_dev 配置的 ignore 值是否为 0?[>>[A]]：==>>
			[A] in_dev 是否配置了 ARP 过滤?[>>(i)]:[>>[B]]
				(i) in_dev 配置的 filter 是否为 0?[>>[B]]:==>>
			[B] n=neigh_event_ns()，返回不为空?[>>(i)]:==>>
				(i) 发送 ARP 应答包
				(ii) 释放 n
	(c) in_dev 配置为 FORWARD?[>>[1]]:[>>(10)]
		[1] addr_type 为 RTN_UNICAST 且 proxy 或者 vlan 或者 ( rt->dst.dev != dev 且 penigh_lookup)?[>>[A]]:[>>(10)]
			[A] n = neigh_event_ns()?[>>(i)]:[>>[B]]
				(i) 释放 n
			[B] flags 为 LOCALLY_ENQUEUED 或者 包类型是发往本机的 或者 ARP 参数 PROXY_DELAY 为 0?[>>(i)]:[>>[C]]
				(i) 发送 ARP 应答包
			[C] pneigh_enqueue()
			[D] ==>>

(10) arp_tbl 中查找 IP 为 sip 的 neighbour 项，结果返回 n。

(11) in_dev 上面配置的是否可以接受 arp 报文?[>>(a)]:[>>(b)]
	(a) 没有 n ?[>>[1]]:[>>(12)]
		[1] 收到的是 ARP 应答报文，且 sip 的地址类型是单播地址，或者收到的报文是一个免费 ARP 包?[>>[A]]:[>>(12)]
			[A] arp_tbl 中查找 IP 为 sip 的 neighbour 项， 没有就创建这个项，并且返回该项 n 。

(12) n 非空?[>>(a)]:[>>(13)]
	(a) state=NUD_REACHABLE
	(b) ARP 更新时间超时 或者 收到的是免费 ARP?override=1:override=0
	(c) 如果收到的是 ARP 应答包，或者包的类型是发往本机的包?[>>[1]]:[>>(13)]
		[1] state=NUD_STALE
	(d) override?[>>[1]]:[>>[2]]
		[1] neigh_update(n, sha, state, NEIGH_UPDATE_F_OVERRIDE)
		[2] neigh_update(n, sha, state, 0)
	(3) 释放 n。



# ip_route_input_noref()
	<net/ipv4/route.c>

	int ip_route_input_noref(
		struct sk_buff *skb,
		__be32 daddr,
		__be32 saddr,
		u8 tos,
		struct net_device *dev
	)
(1) daddr 是多播地址吗?[>>(a)]:[>>(2)]
	(a) 从 dev 里面获取 struct in_device *in_dev 。
	(b) 成功获取 in_dev ?[>>(A)]:[>>(c)]
		(A) 发给本机(本机的 IP 加入了相应的组播)返回 1 (our = 1)。
	(c) 没有获取到 in_dev 或者 our 为 0 且设备是一个 l3设备?[>>(A)]:[>>(d)]
		(A) 从 skb->dev 里面再获取一次 struct in_device *ls_in_dev。获取到 l3_in_dev?[>>[1]]:[>>(d)]
			[1] 发给本机(本机的 IP 加入了相应的组播)返回 1 (our = 1)。
	(d) our=1?[>>(A)]:[>>(e)]
		[A] 查找组播路由表(ip_route_input_mc())，返回查找结果。
	(3) 返回 -EINVAL
(2) 查找单播路由表(ip_route_input_slow())，返回查找结果。








# 系统配置

查看系统配置

	sysctl -a

临时修改系统配置

	sysctl -w xx.yy.zz=**

从制定文件加载系统参数，如不指定即从 /etc/sysctl.conf 中加载

	sysctl -p


## ipv4 下网络接口的一些配置

配置项在 include/uapi/linux/ip.h 中定义。

	enum
	{
		IPV4_DEVCONF_FORWARDING=1,
		IPV4_DEVCONF_MC_FORWARDING,
		IPV4_DEVCONF_PROXY_ARP,
		IPV4_DEVCONF_ACCEPT_REDIRECTS,
		IPV4_DEVCONF_SECURE_REDIRECTS,
		IPV4_DEVCONF_SEND_REDIRECTS,
		IPV4_DEVCONF_SHARED_MEDIA,
		IPV4_DEVCONF_RP_FILTER,
		IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE,
		IPV4_DEVCONF_BOOTP_RELAY,
		IPV4_DEVCONF_LOG_MARTIANS,
		IPV4_DEVCONF_TAG,
		IPV4_DEVCONF_ARPFILTER,
		IPV4_DEVCONF_MEDIUM_ID,
		IPV4_DEVCONF_NOXFRM,
		IPV4_DEVCONF_NOPOLICY,
		IPV4_DEVCONF_FORCE_IGMP_VERSION,
		IPV4_DEVCONF_ARP_ANNOUNCE,
		IPV4_DEVCONF_ARP_IGNORE,
		IPV4_DEVCONF_PROMOTE_SECONDARIES,
		IPV4_DEVCONF_ARP_ACCEPT,
		IPV4_DEVCONF_ARP_NOTIFY,
		IPV4_DEVCONF_ACCEPT_LOCAL,
		IPV4_DEVCONF_SRC_VMARK,
		IPV4_DEVCONF_PROXY_ARP_PVLAN,
		IPV4_DEVCONF_ROUTE_LOCALNET,
		IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL,
		IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL,
		IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN,
		IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST,
		IPV4_DEVCONF_DROP_GRATUITOUS_ARP,
		__IPV4_DEVCONF_MAX
	};

这些参数导出到 /proc 文件系统中。

	╔║/proc/sys/net/ipv4/conf/eth0
	╚═>> tree /proc/sys/net/ipv4/conf/eth0/
	/proc/sys/net/ipv4/conf/eth0/
	├── accept_local
	├── accept_redirects
	├── accept_source_route
	├── arp_accept
	├── arp_announce
	├── arp_filter
	├── arp_ignore
	├── arp_notify
	├── bootp_relay
	├── disable_policy
	├── disable_xfrm
	├── force_igmp_version
	├── forwarding
	├── igmpv2_unsolicited_report_interval
	├── igmpv3_unsolicited_report_interval
	├── ignore_routes_with_linkdown
	├── log_martians
	├── mc_forwarding
	├── medium_id
	├── promote_secondaries
	├── proxy_arp
	├── proxy_arp_pvlan
	├── route_localnet
	├── rp_filter
	├── secure_redirects
	├── send_redirects
	├── shared_media
	├── src_valid_mark
	└── tag

参数的解释见 Documentation/networking/ip-sysctl.txt

## 意义

### forwarding

布尔型，表示是否开启转发功能。\
这个参数比较特殊，它的改变会将所有的配置参数恢复到它们的初始状态。(hosts 参见 RFC1122，routers 参见 RFS1812)

|取值|含义|
|:--|:--------------------------------------------------------------------------|
|`0`|disable                                                                    |
|`1`|enable                                                                     |
测试: host 中 eth0 该值为 0; router 中 eth0(lan)/eth1(wan) 值为 1/1。

<hr>

### arp_accept

布尔型，定义对不在ARP表中的IP地址发出的免费ARP请求包的处理方式。如果这个值打开的话，不管是免费ARP请求包还是免费ARP响应包都会触发更新ARP表。如果ARP表已经包含了免费ARP请求包中的IP实例，那么不管这个至开启与否，都会更新ARP表。

|取值|含义|
|:---|--------------------------------------------------------------------------|
|`0` |不在ARP表中创建对应IP的实例|
|`1` |在ARP表中创建对应IP的实例|

<hr>

### arp_announce：
<hr>

### arp_filter
<hr>

### arp_ignore

<hr>

### arp_notify

布尔型，定义模式，来通知地址或者设备的改变。

|取值|含义|
|:---|:---------------------------------------------------------------------------|
|`0` | 什么也不做|
|`1` | 当设备启动或者硬件地址改变时，就发出一个免费ARP请求|

<hr>

### drop_gratuious_arp

布尔型，丢弃所有的免费ARP数据包，比如，已知在网络上有一个好的ARP代理服务器，所有免费ARP数据包就没有必要使用了。(在802.11中，一定要禁用免费ARP以防攻击)。\
默认值：关闭(0)

<hr>

### route_localnet

布尔型，不要认为在路由中，回环地址就是一个不可能出现的源地址或者目的地址。该值的配置可以达到让127/8的网络进行本地路由的目的。\




# 邻居子系统:其他问题

## 本部分涉及的数据结构

在[主要的数据结构](#主要的数据结构)一节中，我们对邻居子系统使用的主要数据结构做了个简单的描述。本节，我们讨论每个结构体的每个字段。

下图给出了邻居子系统设计到的数据结构所在的文件。

	include
	├── net
	│   ├── route.h
	│   ├── dst.h
	│   ├── if_inet6.h
	│   └── neighbour.h
	│   	├── struct neighbour
	│   	├── struct neigh_table
	│   	├── struct neigh_parms
	│   	├── struct neigh_ops
	│   	├── struct neigh_statistics
	│   	└── struct pneigh_entry
	└── linux
		├── netdevice.h
		│	└── syruct hh_cache
		└── inet_device.h
			
	Figure. Distributiton if data structures in kernel files

### neighbour结构

邻居是用struct neighbour结构定义的。该结构比较复杂，包括状态字段、与L3协议的接口相关虚函数、定时器和缓存的L2帧头。

1. struct neighbour __rcu *next

	指向下一个邻居项。

2. struct neigh_table *tbl

	指向该结构体所属的neigh_table。每个协议都有一個neigh_table的实例，该协议下的所有neighbour都被neigh_table管理。

3. struct neigh_parms *parms

	指向neigh_parms结构体，该结构体用来调整邻居想行为。

4. unsigned long confirmed

	时间戳，表示该邻居项可到达性最后验证过的时间。L4协议使用neigh_confirm函数更新这个值。邻居基础结构用neigh_upgrade函数更新它。

5. unsigned long updated

	时间戳，表示neigh_update函数最近一次更新该邻居项的时间，首次初始化由neigh_alloc函数设置。不要将neigh_confirmed和updated混淆，这两个字段表示不同的事件。当邻居的状态改变时，要设置updata字段；而confirmed字段只记录邻居特殊的一次状态改变:当邻居项最近一次证明是有效时，发生的状态转变。

6. rwlock_t lock

	用于在出现竞争时(包括并发的读和写)对neighbour结构进行保护。

7. atomic_t refcnt

	该结构的引用计数。

8. struct sk_buff_head arp_queue

	高层来的数据包中的目的地址还没有被解析，这些封包就会被放入这个缓冲队列中。队列名字虽然叫arp_queue，但是这个队列能被所有协议使用。

8. unsigned int arp_queue_len_bytes

	arp_queue缓冲队列的长度。

9. struct timer_list timer

	用于处理几个任务的定时器。

10. unsigned long used

	邻居项最后一次被使用的时间戳。这个值不会随着数据传输而同步更新。当邻居项还没有到达NUD_CONNECTED态时，这个字段由neigh_resolve_output函数调用neigh_event_send来更新。相应的，当邻居项进入NUD_CONNECTED态时，它的值由neigh_periodic_work更新为该邻居项的可到达性最近被证实的时间。

11. atomic_t probes

	失败的solicitation尝试的次数。它的值由neigh_timer_handler定时器检测。当尝试次数到达允许的最大值时，这个定时器就将该neighbour项转移到NUD_FAILED态。

12. __u8 flags

	这个字段的可选值在include/uapi/linux/neighbour.h文件中。分别为

		NTF_USE
		NTF_SELF
		NTF_MASTER
		NTF_PROXY
		NTF_EXT_LEARNED
		NTF_ROUTER

13. __u8 nud_state

	邻居状态，该字段的可选值在include/uapi/linux/neighbour.h中。分别为

		NUD_INCOMPLETE
		NUD_REACHABLE
		NUD_STALE
		NUD_DELAY
		NUD_PROBE
		NUD_FAILED
		NUD_NOARP
		NUD_PERMANENT
		NUD_NONE

	上述9个值的含义在[基本状态](#基本状态)一节已经介绍过。

14. __u8 type

	邻居地址类型，该字段的可选值在include/uapi/linux/rtnetlink.h中。分别为

		RTN_UNSPEC			未知的路由
		RTN_UNICAST			网关或直接路由
		RTN_LOCAL			本地接收
		RTN_BROADCAST		本地广播接收广播发送
		RTN_ANYCAST			本地广播接收单播发送
		RTN_MULTICAST		多播路由
		RTN_BLACKHOLE		丢弃
		RTN_UNREACHABLE		目标不可达
		RTN_PROHIBIT		管理禁止
		RTN_THROW			不再此路由表中
		RTN_NAT				转发该地址
		RTN_XRESOLVE		使用外部解决

15. __u8 dead

	表示该邻居项是否可以被删除，dead为1，表示该邻居项将被删除，不能在使用。

16. seqlock_t ha_lock

	顺序锁。

17. unsigned char ha[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))]

	与 pkey表示的L3地址相关联的L2地址。

18. struct hh_cache hh

	L2帧头缓存。

19. int (*output)(struct neighbour *, struct sk_buff *)

	用于向邻居传输封包的函数。根据NUD状态，该函数指针指向的函数在该结构体的生存期内可以多次改变。它的初始化用neigh_table结构的constructor方法。当邻居项的状态为NUD_REACHABEL态或者NUD_STALE态时，可以分别通过调用neigh_connect和neigh_suspect函数更新该字段的值。该字段的取值为struct neigh_ops中四个函数之一。

20. const struct neigh_ops *ops

	参见[ops字段中的虚函数](#ops字段中的虚函数)一节。

21.
